!(e => {"object"==typeof exports?module.exports=e():"function"==typeof define&&define.amd?define(e):"undefined"!=typeof window?window.codeboxIO=e():"undefined"!=typeof global?global.codeboxIO=e():"undefined"!=typeof self&&(self.codeboxIO=e())})(() => {
  var define;
  var module;
  var exports;
  return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,e => {var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[(require, module, exports) => {
  module.exports = {
      Client: require('./lib/client')
  };

  },{"./lib/client":5}],2:[(require, module, exports) => {
  var util = require('util');
  var _ = require('underscore');
  var Q = require('q');
  var Model = require('./model');

  var Account = function(...args) {
      Model.apply(this, args);

      _.defaults(this, {
          'token': null,
          'name': null,
          'publicKey': null,
          'plan': {},
          'boxes': 0,
          'repos': [ ]
      });
  };
  util.inherits(Account, Model);

  module.exports = Account;
  },{"./model":6,"q":7,"underscore":11,"util":15}],3:[(require, module, exports) => {
  var util = require('util');
  var _ = require('underscore');
  var Model = require('./model');

  var Addon = function(...args) {
      Model.apply(this, args);

      _.defaults(this, {
          'name': null,
          'updatedAt': 0,
          'git': null,
          'package': {}
      });
  };
  util.inherits(Addon, Model);

  module.exports = Addon;
  },{"./model":6,"underscore":11,"util":15}],4:[(require, module, exports) => {
  var util = require('util');
  var fs = require('fs');
  var _ = require('underscore');
  var request = require('superagent');
  var Q = require('q');
  var Model = require('./model');

  var Box = function(...args) {
      Model.apply(this, args);

      _.defaults(this, {
          'id': null,
          'name': null,
          'description': null,
          'public': true,
          'type': "premium",
          'owner': null,
          'createdAt': 0,
          'uptime': 0,
          'url': null,
          'collaborators': [ ]
      });

      this.content = function(output) {
          var stream = request.get(this.client.config.host+"/api/box/"+this.id+"/content")
          .set('Authorization', this.client.config.token);

          if (output) {
              var d = Q.defer();
              stream.on('data', chunk => {
                  d.notify(chunk.length);
              });
              stream.on('end', () => {
                  d.resolve();
              });
              stream.on('error', err => {
                  d.reject(err);
              });
              stream.pipe(fs.createWriteStream(output));
              return d.promise;
          }

          return Q(stream);
      };
  };
  util.inherits(Box, Model);

  module.exports = Box;
  },{"./model":6,"fs":14,"q":7,"superagent":8,"underscore":11,"util":15}],5:[(require, module, exports) => {
  var request = require('superagent');
  var _ = require('underscore');
  var events = require('events');
  var util = require('util');
  var Q = require('q');

  var Box = require('./box');
  var Account = require('./account');
  var Addon = require('./addon');

  var Client = function(config) {
      events.EventEmitter.call(this);

      this.config = _.defaults({}, config || {}, {
          'host': 'https://api.codebox.io',
          'token': null
      });

      // Do a rest api request
      // mode: get, post, delete, ...
      // method: api method name
      // args: api args
      this.request = function(mode, method, args) {
          var that = this;
          var deferred = Q.defer();

          request[mode.toLowerCase()](this.config.host+"/api/"+method)
          .send(args)
          .set('Authorization', this.config.token)
          .set('Accept', 'application/json')
          .end(res => {
              if (res.ok) {
                  deferred.resolve(res.body);
              } else {
                  that.emit("apierror", res.error, res.text);
                  deferred.reject(res.body.error || res.error);
              }
          });

          return deferred.promise;
      };

      // Resources access
      this.ressource = function(Method, Model, options) {
          options = _.defaults({}, options || {}, {
              'mode': 'get',
              'select': null,
              'argsContext': null
          });

          return _.bind(function() {
              var that = this;
              var method = Method;

              var args = Array.prototype.slice.call(arguments, 0);
              var methodArgs = (method.split("?").length - 1); // n args for this method

              // Bind args in url
              var bindArgs = args.slice(0, methodArgs);
              _.each(bindArgs, arg => {
                  method = method.replace("?", args);
              });

              formArgs = args.slice(methodArgs, 1)[0] || {};

              // Use args context: {a:} -> {b: {a:} }
              if (options.argsContext) {
                  var oldArgs = formArgs;
                  formArgs = {};
                  formArgs[options.argsContext] = oldArgs;
              }

              return this.request(options.mode, method, formArgs).then(function(data) {
                  // Use selector {a: {b:} } -> {b:}
                  if (options.select) {
                      data = data[options.select];
                  }

                  if (!data) {
                      return null;
                  }

                  if (!Model) {
                      return data;
                  }

                  if (!_.isArray(data)) {
                      return new Model(that, data);
                  }
                  return _.map(data, d => new Model(that, d), this);
              });
          }, this);
      }

      // Login
      this.login = function(email, password) {
          var that = this;
          return this.request("POST", "login", {
              'email': email,
              'password': password
          })
          .then(data => new Account(that, data));
      };

      // Get list of boxes
      this.boxes = this.ressource("boxes", Box, {select: 'boxes'});

      // Get a box
      this.box = this.ressource("box/?", Box);

      // Get current account
      this.account = this.ressource("account", Account);

      // Create a box
      this.create = this.ressource("boxes", Box, {mode: 'post', argsContext: 'box'});


      // Get list of addons
      this.addons = this.ressource("addons", Addon, {select: 'addons'});

      // Get an addon
      this.addon = this.ressource("addon/?", Addon);

      // Publish an addon
      this.publishAddon = this.ressource("addons", Addon, {mode: 'post'});

      // Unpublish an addon
      this.unpublishAddon = this.ressource("addon/?", Addon, {mode: 'delete'});
  };
  util.inherits(Client, events.EventEmitter);

  module.exports = Client;
  },{"./account":2,"./addon":3,"./box":4,"events":13,"q":7,"superagent":8,"underscore":11,"util":15}],6:[(require, module, exports) => {
  var events = require('events');
  var _ = require('underscore');
  var util = require('util');

  var Model = function(client, data) {
      events.EventEmitter.call(this);

      // Client
      this.client = client;

      // Properties
      _.extend(this, data || {});
  };
  util.inherits(Model, events.EventEmitter);

  module.exports = Model;
  },{"events":13,"underscore":11,"util":15}],7:[(require, module, exports) => {
  var process=require("__browserify_process");// vim:ts=4:sts=4:sw=4:
  /*!
   *
   * Copyright 2009-2012 Kris Kowal under the terms of the MIT
   * license found at http://github.com/kriskowal/q/raw/master/LICENSE
   *
   * With parts by Tyler Close
   * Copyright 2007-2009 Tyler Close under the terms of the MIT X license found
   * at http://www.opensource.org/licenses/mit-license.html
   * Forked at ref_send.js version: 2009-05-11
   *
   * With parts by Mark Miller
   * Copyright (C) 2011 Google Inc.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   */

  ((definition => {
      // Turn off strict mode for this function so we can assign to global.Q
      /* jshint strict: false */

      // This file will function properly as a <script> tag, or a module
      // using CommonJS and NodeJS or RequireJS module formats.  In
      // Common/Node/RequireJS, the module exports the Q API and when
      // executed as a simple <script>, it creates a Q global instead.

      // Montage Require
      if (typeof bootstrap === "function") {
          bootstrap("promise", definition);

      // CommonJS
      } else if (typeof exports === "object") {
          module.exports = definition();

      // RequireJS
      } else if (typeof define === "function" && define.amd) {
          define(definition);

      // SES (Secure EcmaScript)
      } else if (typeof ses !== "undefined") {
          if (!ses.ok()) {
              return;
          } else {
              ses.makeQ = definition;
          }

      // <script>
      } else {
          Q = definition();
      }

  }))(() => {
  "use strict";

  var hasStacks = false;
  try {
      throw new Error();
  } catch (e) {
      hasStacks = !!e.stack;
  }

  // All code after this point will be filtered from stack traces reported
  // by Q.
  var qStartingLine = captureLine();
  var qFileName;

  // shims

  // used for fallback in "allResolved"
  var noop = () => {};

  // Use the fastest possible means to execute a task in a future turn
  // of the event loop.
  var nextTick =((() => {
      // linked list of tasks (single, with head node)
      var head = {task: void 0, next: null};
      var tail = head;
      var flushing = false;
      var requestTick = void 0;
      var isNodeJS = false;

      function flush() {
          while (head.next) {
              head = head.next;
              var task = head.task;
              head.task = void 0;
              var domain = head.domain;

              if (domain) {
                  head.domain = void 0;
                  domain.enter();
              }

              try {
                  task();

              } catch (e) {
                  if (isNodeJS) {
                      // In node, uncaught exceptions are considered fatal errors.
                      // Re-throw them synchronously to interrupt flushing!

                      // Ensure continuation if the uncaught exception is suppressed
                      // listening "uncaughtException" events (as domains does).
                      // Continue in next event to avoid tick recursion.
                      domain && domain.exit();
                      setTimeout(flush, 0);
                      domain && domain.enter();

                      throw e;

                  } else {
                      // In browsers, uncaught exceptions are not fatal.
                      // Re-throw them asynchronously to avoid slow-downs.
                      setTimeout(() => {
                         throw e;
                      }, 0);
                  }
              }

              if (domain) {
                  domain.exit();
              }
          }

          flushing = false;
      }

      nextTick = task => {
          tail = tail.next = {
              task,
              domain: isNodeJS && process.domain,
              next: null
          };

          if (!flushing) {
              flushing = true;
              requestTick();
          }
      };

      if (typeof process !== "undefined" && process.nextTick) {
          // Node.js before 0.9. Note that some fake-Node environments, like the
          // Mocha test runner, introduce a `process` global without a `nextTick`.
          isNodeJS = true;

          requestTick = () => {
              process.nextTick(flush);
          };

      } else if (typeof setImmediate === "function") {
          // In IE10, Node.js 0.9+, or https://github.com/NobleJS/setImmediate
          if (typeof window !== "undefined") {
              requestTick = setImmediate.bind(window, flush);
          } else {
              requestTick = () => {
                  setImmediate(flush);
              };
          }

      } else if (typeof MessageChannel !== "undefined") {
          // modern browsers
          // http://www.nonblocking.io/2011/06/windownexttick.html
          var channel = new MessageChannel();
          channel.port1.onmessage = flush;
          requestTick = () => {
              channel.port2.postMessage(0);
          };

      } else {
          // old browsers
          requestTick = () => {
              setTimeout(flush, 0);
          };
      }

      return nextTick;
  }))();

  // Attempt to make generics safe in the face of downstream
  // modifications.
  // There is no situation where this is necessary.
  // If you need a security guarantee, these primordials need to be
  // deeply frozen anyway, and if you don’t need a security guarantee,
  // this is just plain paranoid.
  // However, this does have the nice side-effect of reducing the size
  // of the code by reducing x.call() to merely x(), eliminating many
  // hard-to-minify characters.
  // See Mark Miller’s explanation of what this does.
  // http://wiki.ecmascript.org/doku.php?id=conventions:safe_meta_programming
  function uncurryThis(f) {
      var call = Function.call;
      return function(...args) {
          return call.apply(f, args);
      };
  }
  // This is equivalent, but slower:
  // uncurryThis = Function_bind.bind(Function_bind.call);
  // http://jsperf.com/uncurrythis

  var array_slice = uncurryThis(Array.prototype.slice);

  var array_reduce = uncurryThis(
      Array.prototype.reduce || function (callback, basis) {
        var index = 0;
        var length = this.length;
        // concerning the initial value, if one is not provided
        if (arguments.length === 1) {
            // seek to the first value in the array, accounting
            // for the possibility that is is a sparse array
            do {
                if (index in this) {
                    basis = this[index++];
                    break;
                }
                if (++index >= length) {
                    throw new TypeError();
                }
            } while (1);
        }
        // reduce
        for (; index < length; index++) {
            // account for the possibility that the array is sparse
            if (index in this) {
                basis = callback(basis, this[index], index);
            }
        }
        return basis;
      }
  );

  var array_indexOf = uncurryThis(
      Array.prototype.indexOf || function (value) {
          // not a very good shim, but good enough for our one use of it
          for (var i = 0; i < this.length; i++) {
              if (this[i] === value) {
                  return i;
              }
          }
          return -1;
      }
  );

  var array_map = uncurryThis(
      Array.prototype.map || function (callback, thisp) {
          var self = this;
          var collect = [];
          array_reduce(self, (undefined, value, index) => {
              collect.push(callback.call(thisp, value, index, self));
          }, void 0);
          return collect;
      }
  );

  var object_create = Object.create || (prototype => {
      function Type() { }
      Type.prototype = prototype;
      return new Type();
  });

  var object_hasOwnProperty = uncurryThis(Object.prototype.hasOwnProperty);

  var object_keys = Object.keys || (object => {
      var keys = [];
      for (var key in object) {
          if (object_hasOwnProperty(object, key)) {
              keys.push(key);
          }
      }
      return keys;
  });

  var object_toString = uncurryThis(Object.prototype.toString);

  function isObject(value) {
      return value === Object(value);
  }

  // generator related shims

  // FIXME: Remove this function once ES6 generators are in SpiderMonkey.
  function isStopIteration(exception) {
      return (
          object_toString(exception) === "[object StopIteration]" ||
          exception instanceof QReturnValue
      );
  }

  // FIXME: Remove this helper and Q.return once ES6 generators are in
  // SpiderMonkey.
  var QReturnValue;
  if (typeof ReturnValue !== "undefined") {
      QReturnValue = ReturnValue;
  } else {
      QReturnValue = function (value) {
          this.value = value;
      };
  }

  // Until V8 3.19 / Chromium 29 is released, SpiderMonkey is the only
  // engine that has a deployed base of browsers that support generators.
  // However, SM's generators use the Python-inspired semantics of
  // outdated ES6 drafts.  We would like to support ES6, but we'd also
  // like to make it possible to use generators in deployed browsers, so
  // we also support Python-style generators.  At some point we can remove
  // this block.
  var hasES6Generators;
  try {
      /* jshint evil: true, nonew: false */
      new Function("(function* (){ yield 1; })");
      hasES6Generators = true;
  } catch (e) {
      hasES6Generators = false;
  }

  // long stack traces

  var STACK_JUMP_SEPARATOR = "From previous event:";

  function makeStackTraceLong(error, promise) {
      // If possible, transform the error stack trace by removing Node and Q
      // cruft, then concatenating with the stack trace of `promise`. See #57.
      if (hasStacks &&
          promise.stack &&
          typeof error === "object" &&
          error !== null &&
          error.stack &&
          error.stack.indexOf(STACK_JUMP_SEPARATOR) === -1
      ) {
          var stacks = [];
          for (var p = promise; !!p; p = p.source) {
              if (p.stack) {
                  stacks.unshift(p.stack);
              }
          }
          stacks.unshift(error.stack);

          var concatedStacks = stacks.join("\n" + STACK_JUMP_SEPARATOR + "\n");
          error.stack = filterStackString(concatedStacks);
      }
  }

  function filterStackString(stackString) {
      var lines = stackString.split("\n");
      var desiredLines = [];
      for (var i = 0; i < lines.length; ++i) {
          var line = lines[i];

          if (!isInternalFrame(line) && !isNodeFrame(line) && line) {
              desiredLines.push(line);
          }
      }
      return desiredLines.join("\n");
  }

  function isNodeFrame(stackLine) {
      return stackLine.indexOf("(module.js:") !== -1 ||
             stackLine.indexOf("(node.js:") !== -1;
  }

  function getFileNameAndLineNumber(stackLine) {
      // Named functions: "at functionName (filename:lineNumber:columnNumber)"
      // In IE10 function name can have spaces ("Anonymous function") O_o
      var attempt1 = /at .+ \((.+):(\d+):(?:\d+)\)$/.exec(stackLine);
      if (attempt1) {
          return [attempt1[1], Number(attempt1[2])];
      }

      // Anonymous functions: "at filename:lineNumber:columnNumber"
      var attempt2 = /at ([^ ]+):(\d+):(?:\d+)$/.exec(stackLine);
      if (attempt2) {
          return [attempt2[1], Number(attempt2[2])];
      }

      // Firefox style: "function@filename:lineNumber or @filename:lineNumber"
      var attempt3 = /.*@(.+):(\d+)$/.exec(stackLine);
      if (attempt3) {
          return [attempt3[1], Number(attempt3[2])];
      }
  }

  function isInternalFrame(stackLine) {
      var fileNameAndLineNumber = getFileNameAndLineNumber(stackLine);

      if (!fileNameAndLineNumber) {
          return false;
      }

      var fileName = fileNameAndLineNumber[0];
      var lineNumber = fileNameAndLineNumber[1];

      return fileName === qFileName &&
          lineNumber >= qStartingLine &&
          lineNumber <= qEndingLine;
  }

  // discover own file name and line number range for filtering stack
  // traces
  function captureLine() {
      if (!hasStacks) {
          return;
      }

      try {
          throw new Error();
      } catch (e) {
          var lines = e.stack.split("\n");
          var firstLine = lines[0].indexOf("@") > 0 ? lines[1] : lines[2];
          var fileNameAndLineNumber = getFileNameAndLineNumber(firstLine);
          if (!fileNameAndLineNumber) {
              return;
          }

          qFileName = fileNameAndLineNumber[0];
          return fileNameAndLineNumber[1];
      }
  }

  function deprecate(callback, name, alternative) {
      return function(...args) {
          if (typeof console !== "undefined" &&
              typeof console.warn === "function") {
              console.warn(name + " is deprecated, use " + alternative +
                           " instead.", new Error("").stack);
          }
          return callback.apply(callback, args);
      };
  }

  // end of shims
  // beginning of real work

  /**
   * Creates fulfilled promises from non-thenables,
   * Passes Q promises through,
   * Coerces other thenables to Q promises.
   */
  function Q(value) {
      return resolve(value);
  }

  /**
   * Performs a task in a future turn of the event loop.
   * @param {Function} task
   */
  Q.nextTick = nextTick;

  /**
   * Controls whether or not long stack traces will be on
   */
  Q.longStackSupport = false;

  /**
   * Constructs a {promise, resolve, reject} object.
   *
   * `resolve` is a callback to invoke with a more resolved value for the
   * promise. To fulfill the promise, invoke `resolve` with any value that is
   * not a thenable. To reject the promise, invoke `resolve` with a rejected
   * thenable, or invoke `reject` with the reason directly. To resolve the
   * promise to another thenable, thus putting it in the same state, invoke
   * `resolve` with that other thenable.
   */
  Q.defer = defer;
  function defer() {
    // if "messages" is an "Array", that indicates that the promise has not yet
    // been resolved.  If it is "undefined", it has been resolved.  Each
    // element of the messages array is itself an array of complete arguments to
    // forward to the resolved promise.  We coerce the resolution value to a
    // promise using the `resolve` function because it handles both fully
    // non-thenable values and other thenables gracefully.
    var messages = [];

    var progressListeners = [];
    var resolvedPromise;

    var deferred = object_create(defer.prototype);
    var promise = object_create(Promise.prototype);

    promise.promiseDispatch = function (resolve, op, operands) {
        var args = array_slice(arguments);
        if (messages) {
            messages.push(args);
            if (op === "when" && operands[1]) { // progress operand
                progressListeners.push(operands[1]);
            }
        } else {
            nextTick(() => {
                resolvedPromise.promiseDispatch(...args);
            });
        }
    };

    // XXX deprecated
    promise.valueOf = deprecate(() => {
        if (messages) {
            return promise;
        }
        var nearerValue = nearer(resolvedPromise);
        if (isPromise(nearerValue)) {
            resolvedPromise = nearerValue; // shorten chain
        }
        return nearerValue;
    }, "valueOf", "inspect");

    promise.inspect = () => {
        if (!resolvedPromise) {
            return { state: "pending" };
        }
        return resolvedPromise.inspect();
    };

    if (Q.longStackSupport && hasStacks) {
        try {
            throw new Error();
        } catch (e) {
            // NOTE: don't try to use `Error.captureStackTrace` or transfer the
            // accessor around; that causes memory leaks as per GH-111. Just
            // reify the stack trace as a string ASAP.
            //
            // At the same time, cut off the first line; it's always just
            // "[object Promise]\n", as per the `toString`.
            promise.stack = e.stack.substring(e.stack.indexOf("\n") + 1);
        }
    }

    // NOTE: we do the checks for `resolvedPromise` in each method, instead of
    // consolidating them into `become`, since otherwise we'd create new
    // promises with the lines `become(whatever(value))`. See e.g. GH-252.

    function become(newPromise) {
        resolvedPromise = newPromise;
        promise.source = newPromise;

        array_reduce(messages, (undefined, message) => {
            nextTick(() => {
                newPromise.promiseDispatch(...message);
            });
        }, void 0);

        messages = void 0;
        progressListeners = void 0;
    }

    deferred.promise = promise;
    deferred.resolve = value => {
        if (resolvedPromise) {
            return;
        }

        become(resolve(value));
    };

    deferred.fulfill = value => {
        if (resolvedPromise) {
            return;
        }

        become(fulfill(value));
    };
    deferred.reject = reason => {
        if (resolvedPromise) {
            return;
        }

        become(reject(reason));
    };
    deferred.notify = progress => {
        if (resolvedPromise) {
            return;
        }

        array_reduce(progressListeners, (undefined, progressListener) => {
            nextTick(() => {
                progressListener(progress);
            });
        }, void 0);
    };

    return deferred;
  }

  /**
   * Creates a Node-style callback that will resolve or reject the deferred
   * promise.
   * @returns a nodeback
   */
  defer.prototype.makeNodeResolver = function () {
      var self = this;
      return function (error, value) {
          if (error) {
              self.reject(error);
          } else if (arguments.length > 2) {
              self.resolve(array_slice(arguments, 1));
          } else {
              self.resolve(value);
          }
      };
  };

  /**
   * @param resolver {Function} a function that returns nothing and accepts
   * the resolve, reject, and notify functions for a deferred.
   * @returns a promise that may be resolved with the given resolve and reject
   * functions, or rejected by a thrown exception in resolver
   */
  Q.promise = promise;
  function promise(resolver) {
      if (typeof resolver !== "function") {
          throw new TypeError("resolver must be a function.");
      }

      var deferred = defer();
      fcall(
          resolver,
          deferred.resolve,
          deferred.reject,
          deferred.notify
      ).fail(deferred.reject);
      return deferred.promise;
  }

  /**
   * Constructs a Promise with a promise descriptor object and optional fallback
   * function.  The descriptor contains methods like when(rejected), get(name),
   * set(name, value), post(name, args), and delete(name), which all
   * return either a value, a promise for a value, or a rejection.  The fallback
   * accepts the operation name, a resolver, and any further arguments that would
   * have been forwarded to the appropriate method above had a method been
   * provided with the proper name.  The API makes no guarantees about the nature
   * of the returned object, apart from that it is usable whereever promises are
   * bought and sold.
   */
  Q.makePromise = Promise;
  function Promise(descriptor, fallback, inspect) {
      if (fallback === void 0) {
          fallback = op => reject(new Error(
              "Promise does not support operation: " + op
          ));
      }
      if (inspect === void 0) {
          inspect = () => ({
            state: "unknown"
          });
      }

      var promise = object_create(Promise.prototype);

      promise.promiseDispatch = (resolve, op, args) => {
          var result;
          try {
              if (descriptor[op]) {
                  result = descriptor[op].apply(promise, args);
              } else {
                  result = fallback.call(promise, op, args);
              }
          } catch (exception) {
              result = reject(exception);
          }
          if (resolve) {
              resolve(result);
          }
      };

      promise.inspect = inspect;

      // XXX deprecated `valueOf` and `exception` support
      if (inspect) {
          var inspected = inspect();
          if (inspected.state === "rejected") {
              promise.exception = inspected.reason;
          }

          promise.valueOf = deprecate(() => {
              var inspected = inspect();
              if (inspected.state === "pending" ||
                  inspected.state === "rejected") {
                  return promise;
              }
              return inspected.value;
          });
      }

      return promise;
  }

  Promise.prototype.then = function (fulfilled, rejected, progressed) {
      var self = this;
      var deferred = defer();
      var done = false;   // ensure the untrusted promise makes at most a
                          // single call to one of the callbacks

      function _fulfilled(value) {
          try {
              return typeof fulfilled === "function" ? fulfilled(value) : value;
          } catch (exception) {
              return reject(exception);
          }
      }

      function _rejected(exception) {
          if (typeof rejected === "function") {
              makeStackTraceLong(exception, self);
              try {
                  return rejected(exception);
              } catch (newException) {
                  return reject(newException);
              }
          }
          return reject(exception);
      }

      function _progressed(value) {
          return typeof progressed === "function" ? progressed(value) : value;
      }

      nextTick(() => {
          self.promiseDispatch(value => {
              if (done) {
                  return;
              }
              done = true;

              deferred.resolve(_fulfilled(value));
          }, "when", [exception => {
              if (done) {
                  return;
              }
              done = true;

              deferred.resolve(_rejected(exception));
          }]);
      });

      // Progress propagator need to be attached in the current tick.
      self.promiseDispatch(void 0, "when", [void 0, value => {
          var newValue;
          var threw = false;
          try {
              newValue = _progressed(value);
          } catch (e) {
              threw = true;
              if (Q.onerror) {
                  Q.onerror(e);
              } else {
                  throw e;
              }
          }

          if (!threw) {
              deferred.notify(newValue);
          }
      }]);

      return deferred.promise;
  };

  Promise.prototype.thenResolve = function (value) {
      return when(this, () => value);
  };

  Promise.prototype.thenReject = function (reason) {
      return when(this, () => { throw reason; });
  };

  // Chainable methods
  array_reduce(
      [
          "isFulfilled", "isRejected", "isPending",
          "dispatch",
          "when", "spread",
          "get", "set", "del", "delete",
          "post", "send", "mapply", "invoke", "mcall",
          "keys",
          "fapply", "fcall", "fbind",
          "all", "allResolved",
          "timeout", "delay",
          "catch", "finally", "fail", "fin", "progress", "done",
          "nfcall", "nfapply", "nfbind", "denodeify", "nbind",
          "npost", "nsend", "nmapply", "ninvoke", "nmcall",
          "nodeify"
      ],
      (undefined, name) => {
          Promise.prototype[name] = function(...args) {
              return Q[name](...[this].concat(array_slice(args)));
          };
      },
      void 0
  );

  Promise.prototype.toSource = function () {
      return this.toString();
  };

  Promise.prototype.toString = () => "[object Promise]";

  /**
   * If an object is not a promise, it is as "near" as possible.
   * If a promise is rejected, it is as "near" as possible too.
   * If it’s a fulfilled promise, the fulfillment value is nearer.
   * If it’s a deferred promise and the deferred has been resolved, the
   * resolution is "nearer".
   * @param object
   * @returns most resolved (nearest) form of the object
   */

  // XXX should we re-do this?
  Q.nearer = nearer;
  function nearer(value) {
      if (isPromise(value)) {
          var inspected = value.inspect();
          if (inspected.state === "fulfilled") {
              return inspected.value;
          }
      }
      return value;
  }

  /**
   * @returns whether the given object is a promise.
   * Otherwise it is a fulfilled value.
   */
  Q.isPromise = isPromise;
  function isPromise(object) {
      return isObject(object) &&
          typeof object.promiseDispatch === "function" &&
          typeof object.inspect === "function";
  }

  Q.isPromiseAlike = isPromiseAlike;
  function isPromiseAlike(object) {
      return isObject(object) && typeof object.then === "function";
  }

  /**
   * @returns whether the given object is a pending promise, meaning not
   * fulfilled or rejected.
   */
  Q.isPending = isPending;
  function isPending(object) {
      return isPromise(object) && object.inspect().state === "pending";
  }

  /**
   * @returns whether the given object is a value or fulfilled
   * promise.
   */
  Q.isFulfilled = isFulfilled;
  function isFulfilled(object) {
      return !isPromise(object) || object.inspect().state === "fulfilled";
  }

  /**
   * @returns whether the given object is a rejected promise.
   */
  Q.isRejected = isRejected;
  function isRejected(object) {
      return isPromise(object) && object.inspect().state === "rejected";
  }

  //// BEGIN UNHANDLED REJECTION TRACKING

  // This promise library consumes exceptions thrown in handlers so they can be
  // handled by a subsequent promise.  The exceptions get added to this array when
  // they are created, and removed when they are handled.  Note that in ES6 or
  // shimmed environments, this would naturally be a `Set`.
  var unhandledReasons = [];
  var unhandledRejections = [];
  var unhandledReasonsDisplayed = false;
  var trackUnhandledRejections = true;
  function displayUnhandledReasons() {
      if (
          !unhandledReasonsDisplayed &&
          typeof window !== "undefined" &&
          !window.Touch &&
          window.console
      ) {
          console.warn("[Q] Unhandled rejection reasons (should be empty):",
                       unhandledReasons);
      }

      unhandledReasonsDisplayed = true;
  }

  function logUnhandledReasons() {
      for (var i = 0; i < unhandledReasons.length; i++) {
          var reason = unhandledReasons[i];
          if (reason && typeof reason.stack !== "undefined") {
              console.warn("Unhandled rejection reason:", reason.stack);
          } else {
              console.warn("Unhandled rejection reason (no stack):", reason);
          }
      }
  }

  function resetUnhandledRejections() {
      unhandledReasons.length = 0;
      unhandledRejections.length = 0;
      unhandledReasonsDisplayed = false;

      if (!trackUnhandledRejections) {
          trackUnhandledRejections = true;

          // Show unhandled rejection reasons if Node exits without handling an
          // outstanding rejection.  (Note that Browserify presently produces a
          // `process` global without the `EventEmitter` `on` method.)
          if (typeof process !== "undefined" && process.on) {
              process.on("exit", logUnhandledReasons);
          }
      }
  }

  function trackRejection(promise, reason) {
      if (!trackUnhandledRejections) {
          return;
      }

      unhandledRejections.push(promise);
      unhandledReasons.push(reason);
      displayUnhandledReasons();
  }

  function untrackRejection(promise) {
      if (!trackUnhandledRejections) {
          return;
      }

      var at = array_indexOf(unhandledRejections, promise);
      if (at !== -1) {
          unhandledRejections.splice(at, 1);
          unhandledReasons.splice(at, 1);
      }
  }

  Q.resetUnhandledRejections = resetUnhandledRejections;

  Q.getUnhandledReasons = () => // Make a copy so that consumers can't interfere with our internal state.
  unhandledReasons.slice();

  Q.stopUnhandledRejectionTracking = () => {
      resetUnhandledRejections();
      if (typeof process !== "undefined" && process.on) {
          process.removeListener("exit", logUnhandledReasons);
      }
      trackUnhandledRejections = false;
  };

  resetUnhandledRejections();

  //// END UNHANDLED REJECTION TRACKING

  /**
   * Constructs a rejected promise.
   * @param reason value describing the failure
   */
  Q.reject = reject;
  function reject(reason) {
      var rejection = Promise({
          "when": function (rejected) {
              // note that the error has been handled
              if (rejected) {
                  untrackRejection(this);
              }
              return rejected ? rejected(reason) : this;
          }
      }, function fallback() {
          return this;
      }, function inspect() {
          return { state: "rejected", reason };
      });

      // Note that the reason has not been handled.
      trackRejection(rejection, reason);

      return rejection;
  }

  /**
   * Constructs a fulfilled promise for an immediate reference.
   * @param value immediate reference
   */
  Q.fulfill = fulfill;
  function fulfill(value) {
      return Promise({
          "when": function () {
              return value;
          },
          "get": function (name) {
              return value[name];
          },
          "set": function (name, rhs) {
              value[name] = rhs;
          },
          "delete": function (name) {
              delete value[name];
          },
          "post": function (name, args) {
              // Mark Miller proposes that post with no name should apply a
              // promised function.
              if (name === null || name === void 0) {
                  return value.apply(void 0, args);
              } else {
                  return value[name](...args);
              }
          },
          "apply": function (thisP, args) {
              return value.apply(thisP, args);
          },
          "keys": function () {
              return object_keys(value);
          }
      }, void 0, function inspect() {
          return { state: "fulfilled", value };
      });
  }

  /**
   * Constructs a promise for an immediate reference, passes promises through, or
   * coerces promises from different systems.
   * @param value immediate reference or promise
   */
  Q.resolve = resolve;
  function resolve(value) {
      // If the object is already a Promise, return it directly.  This enables
      // the resolve function to both be used to created references from objects,
      // but to tolerably coerce non-promises to promises.
      if (isPromise(value)) {
          return value;
      }

      // assimilate thenables
      if (isPromiseAlike(value)) {
          return coerce(value);
      } else {
          return fulfill(value);
      }
  }

  /**
   * Converts thenables to Q promises.
   * @param promise thenable promise
   * @returns a Q promise
   */
  function coerce(promise) {
      var deferred = defer();
      nextTick(() => {
          try {
              promise.then(deferred.resolve, deferred.reject, deferred.notify);
          } catch (exception) {
              deferred.reject(exception);
          }
      });
      return deferred.promise;
  }

  /**
   * Annotates an object such that it will never be
   * transferred away from this process over any promise
   * communication channel.
   * @param object
   * @returns promise a wrapping of that object that
   * additionally responds to the "isDef" message
   * without a rejection.
   */
  Q.master = master;
  function master(object) {
      return Promise({
          "isDef": function () {}
      }, function fallback(op, args) {
          return dispatch(object, op, args);
      }, () => resolve(object).inspect());
  }

  /**
   * Registers an observer on a promise.
   *
   * Guarantees:
   *
   * 1. that fulfilled and rejected will be called only once.
   * 2. that either the fulfilled callback or the rejected callback will be
   *    called, but not both.
   * 3. that fulfilled and rejected will not be called in this turn.
   *
   * @param value      promise or immediate reference to observe
   * @param fulfilled  function to be called with the fulfilled value
   * @param rejected   function to be called with the rejection exception
   * @param progressed function to be called on any progress notifications
   * @return promise for the return value from the invoked callback
   */
  Q.when = when;
  function when(value, fulfilled, rejected, progressed) {
      return Q(value).then(fulfilled, rejected, progressed);
  }

  /**
   * Spreads the values of a promised array of arguments into the
   * fulfillment callback.
   * @param fulfilled callback that receives variadic arguments from the
   * promised array
   * @param rejected callback that receives the exception if the promise
   * is rejected.
   * @returns a promise for the return value or thrown exception of
   * either callback.
   */
  Q.spread = spread;
  function spread(promise, fulfilled, rejected) {
      return when(promise, valuesOrPromises => all(valuesOrPromises).then(values => fulfilled.apply(void 0, values), rejected), rejected);
  }

  /**
   * The async function is a decorator for generator functions, turning
   * them into asynchronous generators.  Although generators are only part
   * of the newest ECMAScript 6 drafts, this code does not cause syntax
   * errors in older engines.  This code should continue to work and will
   * in fact improve over time as the language improves.
   *
   * ES6 generators are currently part of V8 version 3.19 with the
   * --harmony-generators runtime flag enabled.  SpiderMonkey has had them
   * for longer, but under an older Python-inspired form.  This function
   * works on both kinds of generators.
   *
   * Decorates a generator function such that:
   *  - it may yield promises
   *  - execution will continue when that promise is fulfilled
   *  - the value of the yield expression will be the fulfilled value
   *  - it returns a promise for the return value (when the generator
   *    stops iterating)
   *  - the decorated function returns a promise for the return value
   *    of the generator or the first rejected promise among those
   *    yielded.
   *  - if an error is thrown in the generator, it propagates through
   *    every following yield until it is caught, or until it escapes
   *    the generator function altogether, and is translated into a
   *    rejection for the promise returned by the decorated generator.
   */
  Q.async = async;
  function async(makeGenerator) {
      return function(...args) {
          // when verb is "send", arg is a value
          // when verb is "throw", arg is an exception
          function continuer(verb, arg) {
              var result;
              if (hasES6Generators) {
                  try {
                      result = generator[verb](arg);
                  } catch (exception) {
                      return reject(exception);
                  }
                  if (result.done) {
                      return result.value;
                  } else {
                      return when(result.value, callback, errback);
                  }
              } else {
                  // FIXME: Remove this case when SM does ES6 generators.
                  try {
                      result = generator[verb](arg);
                  } catch (exception) {
                      if (isStopIteration(exception)) {
                          return exception.value;
                      } else {
                          return reject(exception);
                      }
                  }
                  return when(result, callback, errback);
              }
          }
          var generator = makeGenerator.apply(this, args);
          var callback = continuer.bind(continuer, "send");
          var errback = continuer.bind(continuer, "throw");
          return callback();
      };
  }

  /**
   * The spawn function is a small wrapper around async that immediately
   * calls the generator and also ends the promise chain, so that any
   * unhandled errors are thrown instead of forwarded to the error
   * handler. This is useful because it's extremely common to run
   * generators at the top-level to work with libraries.
   */
  Q.spawn = spawn;
  function spawn(makeGenerator) {
      Q.done(Q.async(makeGenerator)());
  }

  // FIXME: Remove this interface once ES6 generators are in SpiderMonkey.
  /**
   * Throws a ReturnValue exception to stop an asynchronous generator.
   *
   * This interface is a stop-gap measure to support generator return
   * values in older Firefox/SpiderMonkey.  In browsers that support ES6
   * generators like Chromium 29, just use "return" in your generator
   * functions.
   *
   * @param value the return value for the surrounding generator
   * @throws ReturnValue exception with the value.
   * @example
   * // ES6 style
   * Q.async(function* () {
   *      var foo = yield getFooPromise();
   *      var bar = yield getBarPromise();
   *      return foo + bar;
   * })
   * // Older SpiderMonkey style
   * Q.async(function () {
   *      var foo = yield getFooPromise();
   *      var bar = yield getBarPromise();
   *      Q.return(foo + bar);
   * })
   */
  Q["return"] = _return;
  function _return(value) {
      throw new QReturnValue(value);
  }

  /**
   * The promised function decorator ensures that any promise arguments
   * are settled and passed as values (`this` is also settled and passed
   * as a value).  It will also ensure that the result of a function is
   * always a promise.
   *
   * @example
   * var add = Q.promised(function (a, b) {
   *     return a + b;
   * });
   * add(Q.resolve(a), Q.resolve(B));
   *
   * @param {function} callback The function to decorate
   * @returns {function} a function that has been decorated.
   */
  Q.promised = promised;
  function promised(callback) {
      return function(...args) {
          return spread([this, all(args)], (self, args) => callback.apply(self, args));
      };
  }

  /**
   * sends a message to a value in a future turn
   * @param object* the recipient
   * @param op the name of the message operation, e.g., "when",
   * @param args further arguments to be forwarded to the operation
   * @returns result {Promise} a promise for the result of the operation
   */
  Q.dispatch = dispatch;
  function dispatch(object, op, args) {
      var deferred = defer();
      nextTick(() => {
          resolve(object).promiseDispatch(deferred.resolve, op, args);
      });
      return deferred.promise;
  }

  /**
   * Constructs a promise method that can be used to safely observe resolution of
   * a promise for an arbitrarily named method like "propfind" in a future turn.
   *
   * "dispatcher" constructs methods like "get(promise, name)" and "set(promise)".
   */
  Q.dispatcher = dispatcher;
  function dispatcher(op) {
      return function (object) {
          var args = array_slice(arguments, 1);
          return dispatch(object, op, args);
      };
  }

  /**
   * Gets the value of a property in a future turn.
   * @param object    promise or immediate reference for target object
   * @param name      name of property to get
   * @return promise for the property value
   */
  Q.get = dispatcher("get");

  /**
   * Sets the value of a property in a future turn.
   * @param object    promise or immediate reference for object object
   * @param name      name of property to set
   * @param value     new value of property
   * @return promise for the return value
   */
  Q.set = dispatcher("set");

  /**
   * Deletes a property in a future turn.
   * @param object    promise or immediate reference for target object
   * @param name      name of property to delete
   * @return promise for the return value
   */
  Q["delete"] = // XXX experimental
  Q.del = dispatcher("delete");

  /**
   * Invokes a method in a future turn.
   * @param object    promise or immediate reference for target object
   * @param name      name of method to invoke
   * @param value     a value to post, typically an array of
   *                  invocation arguments for promises that
   *                  are ultimately backed with `resolve` values,
   *                  as opposed to those backed with URLs
   *                  wherein the posted value can be any
   *                  JSON serializable object.
   * @return promise for the return value
   */
  // bound locally because it is used by other methods
  var post = Q.post = dispatcher("post");
  Q.mapply = post; // experimental

  /**
   * Invokes a method in a future turn.
   * @param object    promise or immediate reference for target object
   * @param name      name of method to invoke
   * @param ...args   array of invocation arguments
   * @return promise for the return value
   */
  Q.send = send;
  Q.invoke = send; // synonyms
  Q.mcall = send; // experimental
  function send(value, name) {
      var args = array_slice(arguments, 2);
      return post(value, name, args);
  }

  /**
   * Applies the promised function in a future turn.
   * @param object    promise or immediate reference for target function
   * @param args      array of application arguments
   */
  Q.fapply = fapply;
  function fapply(value, args) {
      return dispatch(value, "apply", [void 0, args]);
  }

  /**
   * Calls the promised function in a future turn.
   * @param object    promise or immediate reference for target function
   * @param ...args   array of application arguments
   */
  Q["try"] = fcall; // XXX experimental
  Q.fcall = fcall;
  function fcall(value) {
      var args = array_slice(arguments, 1);
      return fapply(value, args);
  }

  /**
   * Binds the promised function, transforming return values into a fulfilled
   * promise and thrown errors into a rejected one.
   * @param object    promise or immediate reference for target function
   * @param ...args   array of application arguments
   */
  Q.fbind = fbind;
  function fbind(value) {
      var args = array_slice(arguments, 1);
      return function fbound() {
          var allArgs = args.concat(array_slice(arguments));
          return dispatch(value, "apply", [this, allArgs]);
      };
  }

  /**
   * Requests the names of the owned properties of a promised
   * object in a future turn.
   * @param object    promise or immediate reference for target object
   * @return promise for the keys of the eventually settled object
   */
  Q.keys = dispatcher("keys");

  /**
   * Turns an array of promises into a promise for an array.  If any of
   * the promises gets rejected, the whole array is rejected immediately.
   * @param {Array*} an array (or promise for an array) of values (or
   * promises for values)
   * @returns a promise for an array of the corresponding values
   */
  // By Mark Miller
  // http://wiki.ecmascript.org/doku.php?id=strawman:concurrency&rev=1308776521#allfulfilled
  Q.all = all;
  function all(promises) {
      return when(promises, promises => {
          var countDown = 0;
          var deferred = defer();
          array_reduce(promises, (undefined, promise, index) => {
              var snapshot;
              if (
                  isPromise(promise) &&
                  (snapshot = promise.inspect()).state === "fulfilled"
              ) {
                  promises[index] = snapshot.value;
              } else {
                  ++countDown;
                  when(promise, value => {
                      promises[index] = value;
                      if (--countDown === 0) {
                          deferred.resolve(promises);
                      }
                  }, deferred.reject);
              }
          }, void 0);
          if (countDown === 0) {
              deferred.resolve(promises);
          }
          return deferred.promise;
      });
  }

  /**
   * Waits for all promises to be settled, either fulfilled or
   * rejected.  This is distinct from `all` since that would stop
   * waiting at the first rejection.  The promise returned by
   * `allResolved` will never be rejected.
   * @param promises a promise for an array (or an array) of promises
   * (or values)
   * @return a promise for an array of promises
   */
  Q.allResolved = deprecate(allResolved, "allResolved", "allSettled");
  function allResolved(promises) {
      return when(promises, promises => {
          promises = array_map(promises, resolve);
          return when(all(array_map(promises, promise => when(promise, noop, noop))), () => promises);
      });
  }

  Q.allSettled = allSettled;
  function allSettled(values) {
      return when(values, values => all(array_map(values, (value, i) => when(
          value,
          fulfillmentValue => {
              values[i] = { state: "fulfilled", value: fulfillmentValue };
              return values[i];
          },
          reason => {
              values[i] = { state: "rejected", reason };
              return values[i];
          }
      ))).thenResolve(values));
  }

  /**
   * Captures the failure of a promise, giving an oportunity to recover
   * with a callback.  If the given promise is fulfilled, the returned
   * promise is fulfilled.
   * @param {Any*} promise for something
   * @param {Function} callback to fulfill the returned promise if the
   * given promise is rejected
   * @returns a promise for the return value of the callback
   */
  Q["catch"] = // XXX experimental
  Q.fail = fail;
  function fail(promise, rejected) {
      return when(promise, void 0, rejected);
  }

  /**
   * Attaches a listener that can respond to progress notifications from a
   * promise's originating deferred. This listener receives the exact arguments
   * passed to ``deferred.notify``.
   * @param {Any*} promise for something
   * @param {Function} callback to receive any progress notifications
   * @returns the given promise, unchanged
   */
  Q.progress = progress;
  function progress(promise, progressed) {
      return when(promise, void 0, void 0, progressed);
  }

  /**
   * Provides an opportunity to observe the settling of a promise,
   * regardless of whether the promise is fulfilled or rejected.  Forwards
   * the resolution to the returned promise when the callback is done.
   * The callback can return a promise to defer completion.
   * @param {Any*} promise
   * @param {Function} callback to observe the resolution of the given
   * promise, takes no arguments.
   * @returns a promise for the resolution of the given promise when
   * ``fin`` is done.
   */
  Q["finally"] = // XXX experimental
  Q.fin = fin;
  function fin(promise, callback) {
      return when(promise, value => when(callback(), () => value), exception => when(callback(), () => reject(exception)));
  }

  /**
   * Terminates a chain of promises, forcing rejections to be
   * thrown as exceptions.
   * @param {Any*} promise at the end of a chain of promises
   * @returns nothing
   */
  Q.done = done;
  function done(promise, fulfilled, rejected, progress) {
      var onUnhandledError = error => {
          // forward to a future turn so that ``when``
          // does not catch it and turn it into a rejection.
          nextTick(() => {
              makeStackTraceLong(error, promise);

              if (Q.onerror) {
                  Q.onerror(error);
              } else {
                  throw error;
              }
          });
      };

      // Avoid unnecessary `nextTick`ing via an unnecessary `when`.
      var promiseToHandle = fulfilled || rejected || progress ?
          when(promise, fulfilled, rejected, progress) :
          promise;

      if (typeof process === "object" && process && process.domain) {
          onUnhandledError = process.domain.bind(onUnhandledError);
      }
      fail(promiseToHandle, onUnhandledError);
  }

  /**
   * Causes a promise to be rejected if it does not get fulfilled before
   * some milliseconds time out.
   * @param {Any*} promise
   * @param {Number} milliseconds timeout
   * @param {String} custom error message (optional)
   * @returns a promise for the resolution of the given promise if it is
   * fulfilled before the timeout, otherwise rejected.
   */
  Q.timeout = timeout;
  function timeout(promise, ms, msg) {
      var deferred = defer();
      var timeoutId = setTimeout(() => {
          deferred.reject(new Error(msg || "Timed out after " + ms + " ms"));
      }, ms);

      when(promise, value => {
          clearTimeout(timeoutId);
          deferred.resolve(value);
      }, exception => {
          clearTimeout(timeoutId);
          deferred.reject(exception);
      }, deferred.notify);

      return deferred.promise;
  }

  /**
   * Returns a promise for the given value (or promised value) after some
   * milliseconds.
   * @param {Any*} promise
   * @param {Number} milliseconds
   * @returns a promise for the resolution of the given promise after some
   * time has elapsed.
   */
  Q.delay = delay;
  function delay(promise, timeout) {
      if (timeout === void 0) {
          timeout = promise;
          promise = void 0;
      }

      var deferred = defer();

      when(promise, undefined, undefined, deferred.notify);
      setTimeout(() => {
          deferred.resolve(promise);
      }, timeout);

      return deferred.promise;
  }

  /**
   * Passes a continuation to a Node function, which is called with the given
   * arguments provided as an array, and returns a promise.
   *
   *      Q.nfapply(FS.readFile, [__filename])
   *      .then(function (content) {
   *      })
   *
   */
  Q.nfapply = nfapply;
  function nfapply(callback, args) {
      var nodeArgs = array_slice(args);
      var deferred = defer();
      nodeArgs.push(deferred.makeNodeResolver());

      fapply(callback, nodeArgs).fail(deferred.reject);
      return deferred.promise;
  }

  /**
   * Passes a continuation to a Node function, which is called with the given
   * arguments provided individually, and returns a promise.
   *
   *      Q.nfcall(FS.readFile, __filename)
   *      .then(function (content) {
   *      })
   *
   */
  Q.nfcall = nfcall;
  function nfcall(callback/*, ...args */) {
      var nodeArgs = array_slice(arguments, 1);
      var deferred = defer();
      nodeArgs.push(deferred.makeNodeResolver());

      fapply(callback, nodeArgs).fail(deferred.reject);
      return deferred.promise;
  }

  /**
   * Wraps a NodeJS continuation passing function and returns an equivalent
   * version that returns a promise.
   *
   *      Q.nfbind(FS.readFile, __filename)("utf-8")
   *      .then(console.log)
   *      .done()
   *
   */
  Q.nfbind = nfbind;
  Q.denodeify = Q.nfbind; // synonyms
  function nfbind(callback/*, ...args */) {
      var baseArgs = array_slice(arguments, 1);
      return function(...args) {
          var nodeArgs = baseArgs.concat(array_slice(args));
          var deferred = defer();
          nodeArgs.push(deferred.makeNodeResolver());

          fapply(callback, nodeArgs).fail(deferred.reject);
          return deferred.promise;
      };
  }

  Q.nbind = nbind;
  function nbind(callback, thisArg /*, ... args*/) {
      var baseArgs = array_slice(arguments, 2);
      return function(...args) {
          var nodeArgs = baseArgs.concat(array_slice(args));
          var deferred = defer();
          nodeArgs.push(deferred.makeNodeResolver());

          function bound(...args) {
              return callback.apply(thisArg, args);
          }

          fapply(bound, nodeArgs).fail(deferred.reject);
          return deferred.promise;
      };
  }

  /**
   * Calls a method of a Node-style object that accepts a Node-style
   * callback with a given array of arguments, plus a provided callback.
   * @param object an object that has the named method
   * @param {String} name name of the method of object
   * @param {Array} args arguments to pass to the method; the callback
   * will be provided by Q and appended to these arguments.
   * @returns a promise for the value or error
   */
  Q.npost = npost;
  Q.nmapply = npost; // synonyms
  function npost(object, name, args) {
      var nodeArgs = array_slice(args || []);
      var deferred = defer();
      nodeArgs.push(deferred.makeNodeResolver());

      post(object, name, nodeArgs).fail(deferred.reject);
      return deferred.promise;
  }

  /**
   * Calls a method of a Node-style object that accepts a Node-style
   * callback, forwarding the given variadic arguments, plus a provided
   * callback argument.
   * @param object an object that has the named method
   * @param {String} name name of the method of object
   * @param ...args arguments to pass to the method; the callback will
   * be provided by Q and appended to these arguments.
   * @returns a promise for the value or error
   */
  Q.nsend = nsend;
  Q.ninvoke = Q.nsend; // synonyms
  Q.nmcall = Q.nsend; // synonyms
  function nsend(object, name /*, ...args*/) {
      var nodeArgs = array_slice(arguments, 2);
      var deferred = defer();
      nodeArgs.push(deferred.makeNodeResolver());
      post(object, name, nodeArgs).fail(deferred.reject);
      return deferred.promise;
  }

  Q.nodeify = nodeify;
  function nodeify(promise, nodeback) {
      if (nodeback) {
          promise.then(value => {
              nextTick(() => {
                  nodeback(null, value);
              });
          }, error => {
              nextTick(() => {
                  nodeback(error);
              });
          });
      } else {
          return promise;
      }
  }

  // All code before this point will be filtered from stack traces.
  var qEndingLine = captureLine();

  return Q;

  });

  },{"__browserify_process":16}],8:[function(require,module,exports){
  /**
   * Module dependencies.
   */

  var Emitter = require('emitter');
  var reduce = require('reduce');

  /**
   * Root reference for iframes.
   */

  var root = 'undefined' == typeof window
    ? this
    : window;

  /**
   * Noop.
   */

  function noop(){};

  /**
   * Check if `obj` is a host object,
   * we don't want to serialize these :)
   *
   * TODO: future proof, move to compoent land
   *
   * @param {Object} obj
   * @return {Boolean}
   * @api private
   */

  function isHost(obj) {
    var str = {}.toString.call(obj);

    switch (str) {
      case '[object File]':
      case '[object Blob]':
      case '[object FormData]':
        return true;
      default:
        return false;
    }
  }

  /**
   * Determine XHR.
   */

  function getXHR() {
    if (root.XMLHttpRequest
      && ('file:' != root.location.protocol || !root.ActiveXObject)) {
      return new XMLHttpRequest;
    } else {
      try { return new ActiveXObject('Microsoft.XMLHTTP'); } catch(e) {}
      try { return new ActiveXObject('Msxml2.XMLHTTP.6.0'); } catch(e) {}
      try { return new ActiveXObject('Msxml2.XMLHTTP.3.0'); } catch(e) {}
      try { return new ActiveXObject('Msxml2.XMLHTTP'); } catch(e) {}
    }
    return false;
  }

  /**
   * Removes leading and trailing whitespace, added to support IE.
   *
   * @param {String} s
   * @return {String}
   * @api private
   */

  var trim = ''.trim
    ? s => s.trim()
    : s => s.replace(/(^\s*|\s*$)/g, '');

  /**
   * Check if `obj` is an object.
   *
   * @param {Object} obj
   * @return {Boolean}
   * @api private
   */

  function isObject(obj) {
    return obj === Object(obj);
  }

  /**
   * Serialize the given `obj`.
   *
   * @param {Object} obj
   * @return {String}
   * @api private
   */

  function serialize(obj) {
    if (!isObject(obj)) return obj;
    var pairs = [];
    for (var key in obj) {
      if (null != obj[key]) {
        pairs.push(encodeURIComponent(key)
          + '=' + encodeURIComponent(obj[key]));
      }
    }
    return pairs.join('&');
  }

  /**
   * Expose serialization method.
   */

   request.serializeObject = serialize;

   /**
    * Parse the given x-www-form-urlencoded `str`.
    *
    * @param {String} str
    * @return {Object}
    * @api private
    */

  function parseString(str) {
    var obj = {};
    var pairs = str.split('&');
    var parts;
    var pair;

    for (var i = 0, len = pairs.length; i < len; ++i) {
      pair = pairs[i];
      parts = pair.split('=');
      obj[decodeURIComponent(parts[0])] = decodeURIComponent(parts[1]);
    }

    return obj;
  }

  /**
   * Expose parser.
   */

  request.parseString = parseString;

  /**
   * Default MIME type map.
   *
   *     superagent.types.xml = 'application/xml';
   *
   */

  request.types = {
    html: 'text/html',
    json: 'application/json',
    xml: 'application/xml',
    urlencoded: 'application/x-www-form-urlencoded',
    'form': 'application/x-www-form-urlencoded',
    'form-data': 'application/x-www-form-urlencoded'
  };

  /**
   * Default serialization map.
   *
   *     superagent.serialize['application/xml'] = function(obj){
   *       return 'generated xml here';
   *     };
   *
   */

   request.serialize = {
     'application/x-www-form-urlencoded': serialize,
     'application/json': JSON.stringify
   };

   /**
    * Default parsers.
    *
    *     superagent.parse['application/xml'] = function(str){
    *       return { object parsed from str };
    *     };
    *
    */

  request.parse = {
    'application/x-www-form-urlencoded': parseString,
    'application/json': JSON.parse
  };

  /**
   * Parse the given header `str` into
   * an object containing the mapped fields.
   *
   * @param {String} str
   * @return {Object}
   * @api private
   */

  function parseHeader(str) {
    var lines = str.split(/\r?\n/);
    var fields = {};
    var index;
    var line;
    var field;
    var val;

    lines.pop(); // trailing CRLF

    for (var i = 0, len = lines.length; i < len; ++i) {
      line = lines[i];
      index = line.indexOf(':');
      field = line.slice(0, index).toLowerCase();
      val = trim(line.slice(index + 1));
      fields[field] = val;
    }

    return fields;
  }

  /**
   * Return the mime type for the given `str`.
   *
   * @param {String} str
   * @return {String}
   * @api private
   */

  function type(str){
    return str.split(/ *; */).shift();
  };

  /**
   * Return header field parameters.
   *
   * @param {String} str
   * @return {Object}
   * @api private
   */

  function params(str){
    return reduce(str.split(/ *; */), (obj, str) => {
      var parts = str.split(/ *= */);
      var key = parts.shift();
      var val = parts.shift();

      if (key && val) obj[key] = val;
      return obj;
    }, {});
  };

  /**
   * Initialize a new `Response` with the given `xhr`.
   *
   *  - set flags (.ok, .error, etc)
   *  - parse header
   *
   * Examples:
   *
   *  Aliasing `superagent` as `request` is nice:
   *
   *      request = superagent;
   *
   *  We can use the promise-like API, or pass callbacks:
   *
   *      request.get('/').end(function(res){});
   *      request.get('/', function(res){});
   *
   *  Sending data can be chained:
   *
   *      request
   *        .post('/user')
   *        .send({ name: 'tj' })
   *        .end(function(res){});
   *
   *  Or passed to `.send()`:
   *
   *      request
   *        .post('/user')
   *        .send({ name: 'tj' }, function(res){});
   *
   *  Or passed to `.post()`:
   *
   *      request
   *        .post('/user', { name: 'tj' })
   *        .end(function(res){});
   *
   * Or further reduced to a single call for simple cases:
   *
   *      request
   *        .post('/user', { name: 'tj' }, function(res){});
   *
   * @param {XMLHTTPRequest} xhr
   * @param {Object} options
   * @api private
   */

  function Response(req, options) {
    options = options || {};
    this.req = req;
    this.xhr = this.req.xhr;
    this.text = this.xhr.responseText;
    this.setStatusProperties(this.xhr.status);
    this.header = this.headers = parseHeader(this.xhr.getAllResponseHeaders());
    // getAllResponseHeaders sometimes falsely returns "" for CORS requests, but
    // getResponseHeader still works. so we get content-type even if getting
    // other headers fails.
    this.header['content-type'] = this.xhr.getResponseHeader('content-type');
    this.setHeaderProperties(this.header);
    this.body = this.req.method != 'HEAD'
      ? this.parseBody(this.text)
      : null;
  }

  /**
   * Get case-insensitive `field` value.
   *
   * @param {String} field
   * @return {String}
   * @api public
   */

  Response.prototype.get = function(field){
    return this.header[field.toLowerCase()];
  };

  /**
   * Set header related properties:
   *
   *   - `.type` the content type without params
   *
   * A response of "Content-Type: text/plain; charset=utf-8"
   * will provide you with a `.type` of "text/plain".
   *
   * @param {Object} header
   * @api private
   */

  Response.prototype.setHeaderProperties = function(header){
    // content-type
    var ct = this.header['content-type'] || '';
    this.type = type(ct);

    // params
    var obj = params(ct);
    for (var key in obj) this[key] = obj[key];
  };

  /**
   * Parse the given body `str`.
   *
   * Used for auto-parsing of bodies. Parsers
   * are defined on the `superagent.parse` object.
   *
   * @param {String} str
   * @return {Mixed}
   * @api private
   */

  Response.prototype.parseBody = function(str){
    var parse = request.parse[this.type];
    return parse
      ? parse(str)
      : null;
  };

  /**
   * Set flags such as `.ok` based on `status`.
   *
   * For example a 2xx response will give you a `.ok` of __true__
   * whereas 5xx will be __false__ and `.error` will be __true__. The
   * `.clientError` and `.serverError` are also available to be more
   * specific, and `.statusType` is the class of error ranging from 1..5
   * sometimes useful for mapping respond colors etc.
   *
   * "sugar" properties are also defined for common cases. Currently providing:
   *
   *   - .noContent
   *   - .badRequest
   *   - .unauthorized
   *   - .notAcceptable
   *   - .notFound
   *
   * @param {Number} status
   * @api private
   */

  Response.prototype.setStatusProperties = function(status){
    var type = status / 100 | 0;

    // status / class
    this.status = status;
    this.statusType = type;

    // basics
    this.info = 1 == type;
    this.ok = 2 == type;
    this.clientError = 4 == type;
    this.serverError = 5 == type;
    this.error = (4 == type || 5 == type)
      ? this.toError()
      : false;

    // sugar
    this.accepted = 202 == status;
    this.noContent = 204 == status || 1223 == status;
    this.badRequest = 400 == status;
    this.unauthorized = 401 == status;
    this.notAcceptable = 406 == status;
    this.notFound = 404 == status;
    this.forbidden = 403 == status;
  };

  /**
   * Return an `Error` representative of this response.
   *
   * @return {Error}
   * @api public
   */

  Response.prototype.toError = function(){
    var req = this.req;
    var method = req.method;
    var path = req.path;

    var msg = 'cannot ' + method + ' ' + path + ' (' + this.status + ')';
    var err = new Error(msg);
    err.status = this.status;
    err.method = method;
    err.path = path;

    return err;
  };

  /**
   * Expose `Response`.
   */

  request.Response = Response;

  /**
   * Initialize a new `Request` with the given `method` and `url`.
   *
   * @param {String} method
   * @param {String} url
   * @api public
   */

  function Request(method, url) {
    var self = this;
    Emitter.call(this);
    this._query = this._query || [];
    this.method = method;
    this.url = url;
    this.header = {};
    this._header = {};
    this.on('end', () => {
      var res = new Response(self);
      if ('HEAD' == method) res.text = null;
      self.callback(null, res);
    });
  }

  /**
   * Mixin `Emitter`.
   */

  Emitter(Request.prototype);

  /**
   * Allow for extension
   */

  Request.prototype.use = function(fn) {
    fn(this);
    return this;
  }

  /**
   * Set timeout to `ms`.
   *
   * @param {Number} ms
   * @return {Request} for chaining
   * @api public
   */

  Request.prototype.timeout = function(ms){
    this._timeout = ms;
    return this;
  };

  /**
   * Clear previous timeout.
   *
   * @return {Request} for chaining
   * @api public
   */

  Request.prototype.clearTimeout = function(){
    this._timeout = 0;
    clearTimeout(this._timer);
    return this;
  };

  /**
   * Abort the request, and clear potential timeout.
   *
   * @return {Request}
   * @api public
   */

  Request.prototype.abort = function(){
    if (this.aborted) return;
    this.aborted = true;
    this.xhr.abort();
    this.clearTimeout();
    this.emit('abort');
    return this;
  };

  /**
   * Set header `field` to `val`, or multiple fields with one object.
   *
   * Examples:
   *
   *      req.get('/')
   *        .set('Accept', 'application/json')
   *        .set('X-API-Key', 'foobar')
   *        .end(callback);
   *
   *      req.get('/')
   *        .set({ Accept: 'application/json', 'X-API-Key': 'foobar' })
   *        .end(callback);
   *
   * @param {String|Object} field
   * @param {String} val
   * @return {Request} for chaining
   * @api public
   */

  Request.prototype.set = function(field, val){
    if (isObject(field)) {
      for (var key in field) {
        this.set(key, field[key]);
      }
      return this;
    }
    this._header[field.toLowerCase()] = val;
    this.header[field] = val;
    return this;
  };

  /**
   * Get case-insensitive header `field` value.
   *
   * @param {String} field
   * @return {String}
   * @api private
   */

  Request.prototype.getHeader = function(field){
    return this._header[field.toLowerCase()];
  };

  /**
   * Set Content-Type to `type`, mapping values from `request.types`.
   *
   * Examples:
   *
   *      superagent.types.xml = 'application/xml';
   *
   *      request.post('/')
   *        .type('xml')
   *        .send(xmlstring)
   *        .end(callback);
   *
   *      request.post('/')
   *        .type('application/xml')
   *        .send(xmlstring)
   *        .end(callback);
   *
   * @param {String} type
   * @return {Request} for chaining
   * @api public
   */

  Request.prototype.type = function(type){
    this.set('Content-Type', request.types[type] || type);
    return this;
  };

  /**
   * Set Accept to `type`, mapping values from `request.types`.
   *
   * Examples:
   *
   *      superagent.types.json = 'application/json';
   *
   *      request.get('/agent')
   *        .accept('json')
   *        .end(callback);
   *
   *      request.get('/agent')
   *        .accept('application/json')
   *        .end(callback);
   *
   * @param {String} accept
   * @return {Request} for chaining
   * @api public
   */

  Request.prototype.accept = function(type){
    this.set('Accept', request.types[type] || type);
    return this;
  };

  /**
   * Set Authorization field value with `user` and `pass`.
   *
   * @param {String} user
   * @param {String} pass
   * @return {Request} for chaining
   * @api public
   */

  Request.prototype.auth = function(user, pass){
    var str = btoa(user + ':' + pass);
    this.set('Authorization', 'Basic ' + str);
    return this;
  };

  /**
  * Add query-string `val`.
  *
  * Examples:
  *
  *   request.get('/shoes')
  *     .query('size=10')
  *     .query({ color: 'blue' })
  *
  * @param {Object|String} val
  * @return {Request} for chaining
  * @api public
  */

  Request.prototype.query = function(val){
    if ('string' != typeof val) val = serialize(val);
    if (val) this._query.push(val);
    return this;
  };

  /**
   * Send `data`, defaulting the `.type()` to "json" when
   * an object is given.
   *
   * Examples:
   *
   *       // querystring
   *       request.get('/search')
   *         .end(callback)
   *
   *       // multiple data "writes"
   *       request.get('/search')
   *         .send({ search: 'query' })
   *         .send({ range: '1..5' })
   *         .send({ order: 'desc' })
   *         .end(callback)
   *
   *       // manual json
   *       request.post('/user')
   *         .type('json')
   *         .send('{"name":"tj"})
   *         .end(callback)
   *
   *       // auto json
   *       request.post('/user')
   *         .send({ name: 'tj' })
   *         .end(callback)
   *
   *       // manual x-www-form-urlencoded
   *       request.post('/user')
   *         .type('form')
   *         .send('name=tj')
   *         .end(callback)
   *
   *       // auto x-www-form-urlencoded
   *       request.post('/user')
   *         .type('form')
   *         .send({ name: 'tj' })
   *         .end(callback)
   *
   *       // defaults to x-www-form-urlencoded
    *      request.post('/user')
    *        .send('name=tobi')
    *        .send('species=ferret')
    *        .end(callback)
   *
   * @param {String|Object} data
   * @return {Request} for chaining
   * @api public
   */

  Request.prototype.send = function(data){
    var obj = isObject(data);
    var type = this.getHeader('Content-Type');

    // merge
    if (obj && isObject(this._data)) {
      for (var key in data) {
        this._data[key] = data[key];
      }
    } else if ('string' == typeof data) {
      if (!type) this.type('form');
      type = this.getHeader('Content-Type');
      if ('application/x-www-form-urlencoded' == type) {
        this._data = this._data
          ? this._data + '&' + data
          : data;
      } else {
        this._data = (this._data || '') + data;
      }
    } else {
      this._data = data;
    }

    if (!obj) return this;
    if (!type) this.type('json');
    return this;
  };

  /**
   * Invoke the callback with `err` and `res`
   * and handle arity check.
   *
   * @param {Error} err
   * @param {Response} res
   * @api private
   */

  Request.prototype.callback = function(err, res){
    var fn = this._callback;
    if (2 == fn.length) return fn(err, res);
    if (err) return this.emit('error', err);
    fn(res);
  };

  /**
   * Invoke callback with x-domain error.
   *
   * @api private
   */

  Request.prototype.crossDomainError = function(){
    var err = new Error('Origin is not allowed by Access-Control-Allow-Origin');
    err.crossDomain = true;
    this.callback(err);
  };

  /**
   * Invoke callback with timeout error.
   *
   * @api private
   */

  Request.prototype.timeoutError = function(){
    var timeout = this._timeout;
    var err = new Error('timeout of ' + timeout + 'ms exceeded');
    err.timeout = timeout;
    this.callback(err);
  };

  /**
   * Enable transmission of cookies with x-domain requests.
   *
   * Note that for this to work the origin must not be
   * using "Access-Control-Allow-Origin" with a wildcard,
   * and also must set "Access-Control-Allow-Credentials"
   * to "true".
   *
   * @api public
   */

  Request.prototype.withCredentials = function(){
    this._withCredentials = true;
    return this;
  };

  /**
   * Initiate request, invoking callback `fn(res)`
   * with an instanceof `Response`.
   *
   * @param {Function} fn
   * @return {Request} for chaining
   * @api public
   */

  Request.prototype.end = function(fn){
    var self = this;
    var xhr = this.xhr = getXHR();
    var query = this._query.join('&');
    var timeout = this._timeout;
    var data = this._data;

    // store callback
    this._callback = fn || noop;

    // state change
    xhr.onreadystatechange = () => {
      if (4 != xhr.readyState) return;
      if (0 == xhr.status) {
        if (self.aborted) return self.timeoutError();
        return self.crossDomainError();
      }
      self.emit('end');
    };

    // progress
    if (xhr.upload) {
      xhr.upload.onprogress = e => {
        e.percent = e.loaded / e.total * 100;
        self.emit('progress', e);
      };
    }

    // timeout
    if (timeout && !this._timer) {
      this._timer = setTimeout(() => {
        self.abort();
      }, timeout);
    }

    // querystring
    if (query) {
      query = request.serializeObject(query);
      this.url += ~this.url.indexOf('?')
        ? '&' + query
        : '?' + query;
    }

    // initiate request
    xhr.open(this.method, this.url, true);

    // CORS
    if (this._withCredentials) xhr.withCredentials = true;

    // body
    if ('GET' != this.method && 'HEAD' != this.method && 'string' != typeof data && !isHost(data)) {
      // serialize stuff
      var serialize = request.serialize[this.getHeader('Content-Type')];
      if (serialize) data = serialize(data);
    }

    // set header fields
    for (var field in this.header) {
      if (null == this.header[field]) continue;
      xhr.setRequestHeader(field, this.header[field]);
    }

    // send stuff
    this.emit('request', this);
    xhr.send(data);
    return this;
  };

  /**
   * Expose `Request`.
   */

  request.Request = Request;

  /**
   * Issue a request:
   *
   * Examples:
   *
   *    request('GET', '/users').end(callback)
   *    request('/users').end(callback)
   *    request('/users', callback)
   *
   * @param {String} method
   * @param {String|Function} url or callback
   * @return {Request}
   * @api public
   */

  function request(method, url) {
    // callback
    if ('function' == typeof url) {
      return new Request('GET', method).end(url);
    }

    // url first
    if (1 == arguments.length) {
      return new Request('GET', method);
    }

    return new Request(method, url);
  }

  /**
   * GET `url` with optional callback `fn(res)`.
   *
   * @param {String} url
   * @param {Mixed|Function} data or fn
   * @param {Function} fn
   * @return {Request}
   * @api public
   */

  request.get = (url, data, fn) => {
    var req = request('GET', url);
    if ('function' == typeof data) fn = data, data = null;
    if (data) req.query(data);
    if (fn) req.end(fn);
    return req;
  };

  /**
   * HEAD `url` with optional callback `fn(res)`.
   *
   * @param {String} url
   * @param {Mixed|Function} data or fn
   * @param {Function} fn
   * @return {Request}
   * @api public
   */

  request.head = (url, data, fn) => {
    var req = request('HEAD', url);
    if ('function' == typeof data) fn = data, data = null;
    if (data) req.send(data);
    if (fn) req.end(fn);
    return req;
  };

  /**
   * DELETE `url` with optional callback `fn(res)`.
   *
   * @param {String} url
   * @param {Function} fn
   * @return {Request}
   * @api public
   */

  request.del = (url, fn) => {
    var req = request('DELETE', url);
    if (fn) req.end(fn);
    return req;
  };

  /**
   * PATCH `url` with optional `data` and callback `fn(res)`.
   *
   * @param {String} url
   * @param {Mixed} data
   * @param {Function} fn
   * @return {Request}
   * @api public
   */

  request.patch = (url, data, fn) => {
    var req = request('PATCH', url);
    if ('function' == typeof data) fn = data, data = null;
    if (data) req.send(data);
    if (fn) req.end(fn);
    return req;
  };

  /**
   * POST `url` with optional `data` and callback `fn(res)`.
   *
   * @param {String} url
   * @param {Mixed} data
   * @param {Function} fn
   * @return {Request}
   * @api public
   */

  request.post = (url, data, fn) => {
    var req = request('POST', url);
    if ('function' == typeof data) fn = data, data = null;
    if (data) req.send(data);
    if (fn) req.end(fn);
    return req;
  };

  /**
   * PUT `url` with optional `data` and callback `fn(res)`.
   *
   * @param {String} url
   * @param {Mixed|Function} data or fn
   * @param {Function} fn
   * @return {Request}
   * @api public
   */

  request.put = (url, data, fn) => {
    var req = request('PUT', url);
    if ('function' == typeof data) fn = data, data = null;
    if (data) req.send(data);
    if (fn) req.end(fn);
    return req;
  };

  /**
   * Expose `request`.
   */

  module.exports = request;

  },{"emitter":9,"reduce":10}],9:[(require, module, exports) => {

  /**
   * Expose `Emitter`.
   */

  module.exports = Emitter;

  /**
   * Initialize a new `Emitter`.
   *
   * @api public
   */

  function Emitter(obj) {
    if (obj) return mixin(obj);
  };

  /**
   * Mixin the emitter properties.
   *
   * @param {Object} obj
   * @return {Object}
   * @api private
   */

  function mixin(obj) {
    for (var key in Emitter.prototype) {
      obj[key] = Emitter.prototype[key];
    }
    return obj;
  }

  /**
   * Listen on the given `event` with `fn`.
   *
   * @param {String} event
   * @param {Function} fn
   * @return {Emitter}
   * @api public
   */

  Emitter.prototype.on = function(event, fn){
    this._callbacks = this._callbacks || {};
    (this._callbacks[event] = this._callbacks[event] || [])
      .push(fn);
    return this;
  };

  /**
   * Adds an `event` listener that will be invoked a single
   * time then automatically removed.
   *
   * @param {String} event
   * @param {Function} fn
   * @return {Emitter}
   * @api public
   */

  Emitter.prototype.once = function(event, fn){
    var self = this;
    this._callbacks = this._callbacks || {};

    function on(...args) {
      self.off(event, on);
      fn.apply(this, args);
    }

    fn._off = on;
    this.on(event, on);
    return this;
  };

  /**
   * Remove the given callback for `event` or all
   * registered callbacks.
   *
   * @param {String} event
   * @param {Function} fn
   * @return {Emitter}
   * @api public
   */

  Emitter.prototype.off =
  Emitter.prototype.removeListener =
  Emitter.prototype.removeAllListeners = function(event, fn){
    this._callbacks = this._callbacks || {};

    // all
    if (0 == arguments.length) {
      this._callbacks = {};
      return this;
    }

    // specific event
    var callbacks = this._callbacks[event];
    if (!callbacks) return this;

    // remove all handlers
    if (1 == arguments.length) {
      delete this._callbacks[event];
      return this;
    }

    // remove specific handler
    var i = callbacks.indexOf(fn._off || fn);
    if (~i) callbacks.splice(i, 1);
    return this;
  };

  /**
   * Emit `event` with the given args.
   *
   * @param {String} event
   * @param {Mixed} ...
   * @return {Emitter}
   */

  Emitter.prototype.emit = function(event){
    this._callbacks = this._callbacks || {};
    var args = [].slice.call(arguments, 1);
    var callbacks = this._callbacks[event];

    if (callbacks) {
      callbacks = callbacks.slice(0);
      for (var i = 0, len = callbacks.length; i < len; ++i) {
        callbacks[i].apply(this, args);
      }
    }

    return this;
  };

  /**
   * Return array of callbacks for `event`.
   *
   * @param {String} event
   * @return {Array}
   * @api public
   */

  Emitter.prototype.listeners = function(event){
    this._callbacks = this._callbacks || {};
    return this._callbacks[event] || [];
  };

  /**
   * Check if this emitter has `event` handlers.
   *
   * @param {String} event
   * @return {Boolean}
   * @api public
   */

  Emitter.prototype.hasListeners = function(event){
    return !! this.listeners(event).length;
  };

  },{}],10:[(require, module, exports) => {

  /**
   * Reduce `arr` with `fn`.
   *
   * @param {Array} arr
   * @param {Function} fn
   * @param {Mixed} initial
   *
   * TODO: combatible error handling?
   */

  module.exports = function(arr, fn, initial){  
    var idx = 0;
    var len = arr.length;
    var curr = arguments.length == 3
      ? initial
      : arr[idx++];

    while (idx < len) {
      curr = fn.call(null, curr, arr[idx], ++idx, arr);
    }
    
    return curr;
  };
  },{}],11:[function(require,module,exports){
  //     Underscore.js 1.4.4
  //     http://underscorejs.org
  //     (c) 2009-2013 Jeremy Ashkenas, DocumentCloud Inc.
  //     Underscore may be freely distributed under the MIT license.

  ((function(...args) {
    // Baseline setup
    // --------------

    // Establish the root object, `window` in the browser, or `global` on the server.
    var root = this;

    // Save the previous value of the `_` variable.
    var previousUnderscore = root._;

    // Establish the object that gets returned to break out of a loop iteration.
    var breaker = {};

    // Save bytes in the minified (but not gzipped) version:
    var ArrayProto = Array.prototype;

    var ObjProto = Object.prototype;
    var FuncProto = Function.prototype;

    // Create quick reference variables for speed access to core prototypes.
    var push             = ArrayProto.push;

    var slice            = ArrayProto.slice;
    var concat           = ArrayProto.concat;
    var toString         = ObjProto.toString;
    var hasOwnProperty   = ObjProto.hasOwnProperty;

    // All **ECMAScript 5** native function implementations that we hope to use
    // are declared here.
    var nativeForEach      = ArrayProto.forEach;

    var nativeMap          = ArrayProto.map;
    var nativeReduce       = ArrayProto.reduce;
    var nativeReduceRight  = ArrayProto.reduceRight;
    var nativeFilter       = ArrayProto.filter;
    var nativeEvery        = ArrayProto.every;
    var nativeSome         = ArrayProto.some;
    var nativeIndexOf      = ArrayProto.indexOf;
    var nativeLastIndexOf  = ArrayProto.lastIndexOf;
    var nativeIsArray      = Array.isArray;
    var nativeKeys         = Object.keys;
    var nativeBind         = FuncProto.bind;

    // Create a safe reference to the Underscore object for use below.
    var _ = function(obj) {
      if (obj instanceof _) return obj;
      if (!(this instanceof _)) return new _(obj);
      this._wrapped = obj;
    };

    // Export the Underscore object for **Node.js**, with
    // backwards-compatibility for the old `require()` API. If we're in
    // the browser, add `_` as a global object via a string identifier,
    // for Closure Compiler "advanced" mode.
    if (typeof exports !== 'undefined') {
      if (typeof module !== 'undefined' && module.exports) {
        exports = module.exports = _;
      }
      exports._ = _;
    } else {
      root._ = _;
    }

    // Current version.
    _.VERSION = '1.4.4';

    // Collection Functions
    // --------------------

    // The cornerstone, an `each` implementation, aka `forEach`.
    // Handles objects with the built-in `forEach`, arrays, and raw objects.
    // Delegates to **ECMAScript 5**'s native `forEach` if available.
    var each = _.each = _.forEach = (obj, iterator, context) => {
      if (obj == null) return;
      if (nativeForEach && obj.forEach === nativeForEach) {
        obj.forEach(iterator, context);
      } else if (obj.length === +obj.length) {
        for (var i = 0, l = obj.length; i < l; i++) {
          if (iterator.call(context, obj[i], i, obj) === breaker) return;
        }
      } else {
        for (var key in obj) {
          if (_.has(obj, key)) {
            if (iterator.call(context, obj[key], key, obj) === breaker) return;
          }
        }
      }
    };

    // Return the results of applying the iterator to each element.
    // Delegates to **ECMAScript 5**'s native `map` if available.
    _.map = _.collect = (obj, iterator, context) => {
      var results = [];
      if (obj == null) return results;
      if (nativeMap && obj.map === nativeMap) return obj.map(iterator, context);
      each(obj, (value, index, list) => {
        results[results.length] = iterator.call(context, value, index, list);
      });
      return results;
    };

    var reduceError = 'Reduce of empty array with no initial value';

    // **Reduce** builds up a single result from a list of values, aka `inject`,
    // or `foldl`. Delegates to **ECMAScript 5**'s native `reduce` if available.
    _.reduce = _.foldl = _.inject = function(obj, iterator, memo, context) {
      var initial = arguments.length > 2;
      if (obj == null) obj = [];
      if (nativeReduce && obj.reduce === nativeReduce) {
        if (context) iterator = _.bind(iterator, context);
        return initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);
      }
      each(obj, (value, index, list) => {
        if (!initial) {
          memo = value;
          initial = true;
        } else {
          memo = iterator.call(context, memo, value, index, list);
        }
      });
      if (!initial) throw new TypeError(reduceError);
      return memo;
    };

    // The right-associative version of reduce, also known as `foldr`.
    // Delegates to **ECMAScript 5**'s native `reduceRight` if available.
    _.reduceRight = _.foldr = function(obj, iterator, memo, context) {
      var initial = arguments.length > 2;
      if (obj == null) obj = [];
      if (nativeReduceRight && obj.reduceRight === nativeReduceRight) {
        if (context) iterator = _.bind(iterator, context);
        return initial ? obj.reduceRight(iterator, memo) : obj.reduceRight(iterator);
      }
      var length = obj.length;
      if (length !== +length) {
        var keys = _.keys(obj);
        length = keys.length;
      }
      each(obj, (value, index, list) => {
        index = keys ? keys[--length] : --length;
        if (!initial) {
          memo = obj[index];
          initial = true;
        } else {
          memo = iterator.call(context, memo, obj[index], index, list);
        }
      });
      if (!initial) throw new TypeError(reduceError);
      return memo;
    };

    // Return the first value which passes a truth test. Aliased as `detect`.
    _.find = _.detect = (obj, iterator, context) => {
      var result;
      any(obj, (value, index, list) => {
        if (iterator.call(context, value, index, list)) {
          result = value;
          return true;
        }
      });
      return result;
    };

    // Return all the elements that pass a truth test.
    // Delegates to **ECMAScript 5**'s native `filter` if available.
    // Aliased as `select`.
    _.filter = _.select = (obj, iterator, context) => {
      var results = [];
      if (obj == null) return results;
      if (nativeFilter && obj.filter === nativeFilter) return obj.filter(iterator, context);
      each(obj, (value, index, list) => {
        if (iterator.call(context, value, index, list)) results[results.length] = value;
      });
      return results;
    };

    // Return all the elements for which a truth test fails.
    _.reject = (obj, iterator, context) => _.filter(obj, (value, index, list) => !iterator.call(context, value, index, list), context);

    // Determine whether all of the elements match a truth test.
    // Delegates to **ECMAScript 5**'s native `every` if available.
    // Aliased as `all`.
    _.every = _.all = (obj, iterator, context) => {
      iterator || (iterator = _.identity);
      var result = true;
      if (obj == null) return result;
      if (nativeEvery && obj.every === nativeEvery) return obj.every(iterator, context);
      each(obj, (value, index, list) => {
        if (!(result = result && iterator.call(context, value, index, list))) return breaker;
      });
      return !!result;
    };

    // Determine if at least one element in the object matches a truth test.
    // Delegates to **ECMAScript 5**'s native `some` if available.
    // Aliased as `any`.
    var any = _.some = _.any = (obj, iterator, context) => {
      iterator || (iterator = _.identity);
      var result = false;
      if (obj == null) return result;
      if (nativeSome && obj.some === nativeSome) return obj.some(iterator, context);
      each(obj, (value, index, list) => {
        if (result || (result = iterator.call(context, value, index, list))) return breaker;
      });
      return !!result;
    };

    // Determine if the array or object contains a given value (using `===`).
    // Aliased as `include`.
    _.contains = _.include = (obj, target) => {
      if (obj == null) return false;
      if (nativeIndexOf && obj.indexOf === nativeIndexOf) return obj.indexOf(target) != -1;
      return any(obj, value => value === target);
    };

    // Invoke a method (with arguments) on every item in a collection.
    _.invoke = function(obj, method) {
      var args = slice.call(arguments, 2);
      var isFunc = _.isFunction(method);
      return _.map(obj, value => (isFunc ? method : value[method]).apply(value, args));
    };

    // Convenience version of a common use case of `map`: fetching a property.
    _.pluck = (obj, key) => _.map(obj, value => value[key]);

    // Convenience version of a common use case of `filter`: selecting only objects
    // containing specific `key:value` pairs.
    _.where = (obj, attrs, first) => {
      if (_.isEmpty(attrs)) return first ? null : [];
      return _[first ? 'find' : 'filter'](obj, value => {
        for (var key in attrs) {
          if (attrs[key] !== value[key]) return false;
        }
        return true;
      });
    };

    // Convenience version of a common use case of `find`: getting the first object
    // containing specific `key:value` pairs.
    _.findWhere = (obj, attrs) => _.where(obj, attrs, true);

    // Return the maximum element or (element-based computation).
    // Can't optimize arrays of integers longer than 65,535 elements.
    // See: https://bugs.webkit.org/show_bug.cgi?id=80797
    _.max = (obj, iterator, context) => {
      if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {
        return Math.max(...obj);
      }
      if (!iterator && _.isEmpty(obj)) return -Infinity;
      var result = {computed : -Infinity, value: -Infinity};
      each(obj, (value, index, list) => {
        var computed = iterator ? iterator.call(context, value, index, list) : value;
        computed >= result.computed && (result = {value, computed});
      });
      return result.value;
    };

    // Return the minimum element (or element-based computation).
    _.min = (obj, iterator, context) => {
      if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {
        return Math.min(...obj);
      }
      if (!iterator && _.isEmpty(obj)) return Infinity;
      var result = {computed : Infinity, value: Infinity};
      each(obj, (value, index, list) => {
        var computed = iterator ? iterator.call(context, value, index, list) : value;
        computed < result.computed && (result = {value, computed});
      });
      return result.value;
    };

    // Shuffle an array.
    _.shuffle = obj => {
      var rand;
      var index = 0;
      var shuffled = [];
      each(obj, value => {
        rand = _.random(index++);
        shuffled[index - 1] = shuffled[rand];
        shuffled[rand] = value;
      });
      return shuffled;
    };

    // An internal function to generate lookup iterators.
    var lookupIterator = value => _.isFunction(value) ? value : obj => obj[value];

    // Sort the object's values by a criterion produced by an iterator.
    _.sortBy = (obj, value, context) => {
      var iterator = lookupIterator(value);
      return _.pluck(_.map(obj, (value, index, list) => ({
        value,
        index,
        criteria : iterator.call(context, value, index, list)
      })).sort((left, right) => {
        var a = left.criteria;
        var b = right.criteria;
        if (a !== b) {
          if (a > b || a === void 0) return 1;
          if (a < b || b === void 0) return -1;
        }
        return left.index < right.index ? -1 : 1;
      }), 'value');
    };

    // An internal function used for aggregate "group by" operations.
    var group = (obj, value, context, behavior) => {
      var result = {};
      var iterator = lookupIterator(value || _.identity);
      each(obj, (value, index) => {
        var key = iterator.call(context, value, index, obj);
        behavior(result, key, value);
      });
      return result;
    };

    // Groups the object's values by a criterion. Pass either a string attribute
    // to group by, or a function that returns the criterion.
    _.groupBy = (obj, value, context) => group(obj, value, context, (result, key, value) => {
      (_.has(result, key) ? result[key] : (result[key] = [])).push(value);
    });

    // Counts instances of an object that group by a certain criterion. Pass
    // either a string attribute to count by, or a function that returns the
    // criterion.
    _.countBy = (obj, value, context) => group(obj, value, context, (result, key) => {
      if (!_.has(result, key)) result[key] = 0;
      result[key]++;
    });

    // Use a comparator function to figure out the smallest index at which
    // an object should be inserted so as to maintain order. Uses binary search.
    _.sortedIndex = (array, obj, iterator, context) => {
      iterator = iterator == null ? _.identity : lookupIterator(iterator);
      var value = iterator.call(context, obj);
      var low = 0;
      var high = array.length;
      while (low < high) {
        var mid = (low + high) >>> 1;
        iterator.call(context, array[mid]) < value ? low = mid + 1 : high = mid;
      }
      return low;
    };

    // Safely convert anything iterable into a real, live array.
    _.toArray = obj => {
      if (!obj) return [];
      if (_.isArray(obj)) return slice.call(obj);
      if (obj.length === +obj.length) return _.map(obj, _.identity);
      return _.values(obj);
    };

    // Return the number of elements in an object.
    _.size = obj => {
      if (obj == null) return 0;
      return (obj.length === +obj.length) ? obj.length : _.keys(obj).length;
    };

    // Array Functions
    // ---------------

    // Get the first element of an array. Passing **n** will return the first N
    // values in the array. Aliased as `head` and `take`. The **guard** check
    // allows it to work with `_.map`.
    _.first = _.head = _.take = (array, n, guard) => {
      if (array == null) return void 0;
      return (n != null) && !guard ? slice.call(array, 0, n) : array[0];
    };

    // Returns everything but the last entry of the array. Especially useful on
    // the arguments object. Passing **n** will return all the values in
    // the array, excluding the last N. The **guard** check allows it to work with
    // `_.map`.
    _.initial = (array, n, guard) => slice.call(array, 0, array.length - ((n == null) || guard ? 1 : n));

    // Get the last element of an array. Passing **n** will return the last N
    // values in the array. The **guard** check allows it to work with `_.map`.
    _.last = (array, n, guard) => {
      if (array == null) return void 0;
      if ((n != null) && !guard) {
        return slice.call(array, Math.max(array.length - n, 0));
      } else {
        return array[array.length - 1];
      }
    };

    // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
    // Especially useful on the arguments object. Passing an **n** will return
    // the rest N values in the array. The **guard**
    // check allows it to work with `_.map`.
    _.rest = _.tail = _.drop = (array, n, guard) => slice.call(array, (n == null) || guard ? 1 : n);

    // Trim out all falsy values from an array.
    _.compact = array => _.filter(array, _.identity);

    // Internal implementation of a recursive `flatten` function.
    var flatten = (input, shallow, output) => {
      each(input, value => {
        if (_.isArray(value)) {
          shallow ? push.apply(output, value) : flatten(value, shallow, output);
        } else {
          output.push(value);
        }
      });
      return output;
    };

    // Return a completely flattened version of an array.
    _.flatten = (array, shallow) => flatten(array, shallow, []);

    // Return a version of the array that does not contain the specified value(s).
    _.without = function(array) {
      return _.difference(array, slice.call(arguments, 1));
    };

    // Produce a duplicate-free version of the array. If the array has already
    // been sorted, you have the option of using a faster algorithm.
    // Aliased as `unique`.
    _.uniq = _.unique = (array, isSorted, iterator, context) => {
      if (_.isFunction(isSorted)) {
        context = iterator;
        iterator = isSorted;
        isSorted = false;
      }
      var initial = iterator ? _.map(array, iterator, context) : array;
      var results = [];
      var seen = [];
      each(initial, (value, index) => {
        if (isSorted ? (!index || seen[seen.length - 1] !== value) : !_.contains(seen, value)) {
          seen.push(value);
          results.push(array[index]);
        }
      });
      return results;
    };

    // Produce an array that contains the union: each distinct element from all of
    // the passed-in arrays.
    _.union = function(...args) {
      return _.uniq(concat.apply(ArrayProto, args));
    };

    // Produce an array that contains every item shared between all the
    // passed-in arrays.
    _.intersection = function(array) {
      var rest = slice.call(arguments, 1);
      return _.filter(_.uniq(array), item => _.every(rest, other => _.indexOf(other, item) >= 0));
    };

    // Take the difference between one array and a number of other arrays.
    // Only the elements present in just the first array will remain.
    _.difference = function(array) {
      var rest = concat.apply(ArrayProto, slice.call(arguments, 1));
      return _.filter(array, value => !_.contains(rest, value));
    };

    // Zip together multiple lists into a single array -- elements that share
    // an index go together.
    _.zip = function() {
      var args = slice.call(arguments);
      var length = _.max(_.pluck(args, 'length'));
      var results = new Array(length);
      for (var i = 0; i < length; i++) {
        results[i] = _.pluck(args, "" + i);
      }
      return results;
    };

    // Converts lists into objects. Pass either a single array of `[key, value]`
    // pairs, or two parallel arrays of the same length -- one of keys, and one of
    // the corresponding values.
    _.object = (list, values) => {
      if (list == null) return {};
      var result = {};
      for (var i = 0, l = list.length; i < l; i++) {
        if (values) {
          result[list[i]] = values[i];
        } else {
          result[list[i][0]] = list[i][1];
        }
      }
      return result;
    };

    // If the browser doesn't supply us with indexOf (I'm looking at you, **MSIE**),
    // we need this function. Return the position of the first occurrence of an
    // item in an array, or -1 if the item is not included in the array.
    // Delegates to **ECMAScript 5**'s native `indexOf` if available.
    // If the array is large and already in sort order, pass `true`
    // for **isSorted** to use binary search.
    _.indexOf = (array, item, isSorted) => {
      if (array == null) return -1;
      var i = 0;
      var l = array.length;
      if (isSorted) {
        if (typeof isSorted == 'number') {
          i = (isSorted < 0 ? Math.max(0, l + isSorted) : isSorted);
        } else {
          i = _.sortedIndex(array, item);
          return array[i] === item ? i : -1;
        }
      }
      if (nativeIndexOf && array.indexOf === nativeIndexOf) return array.indexOf(item, isSorted);
      for (; i < l; i++) if (array[i] === item) return i;
      return -1;
    };

    // Delegates to **ECMAScript 5**'s native `lastIndexOf` if available.
    _.lastIndexOf = (array, item, from) => {
      if (array == null) return -1;
      var hasIndex = from != null;
      if (nativeLastIndexOf && array.lastIndexOf === nativeLastIndexOf) {
        return hasIndex ? array.lastIndexOf(item, from) : array.lastIndexOf(item);
      }
      var i = (hasIndex ? from : array.length);
      while (i--) if (array[i] === item) return i;
      return -1;
    };

    // Generate an integer Array containing an arithmetic progression. A port of
    // the native Python `range()` function. See
    // [the Python documentation](http://docs.python.org/library/functions.html#range).
    _.range = function(start, stop, step) {
      if (arguments.length <= 1) {
        stop = start || 0;
        start = 0;
      }
      step = arguments[2] || 1;

      var len = Math.max(Math.ceil((stop - start) / step), 0);
      var idx = 0;
      var range = new Array(len);

      while(idx < len) {
        range[idx++] = start;
        start += step;
      }

      return range;
    };

    // Function (ahem) Functions
    // ------------------

    // Create a function bound to a given object (assigning `this`, and arguments,
    // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
    // available.
    _.bind = function(func, context) {
      if (func.bind === nativeBind && nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
      var args = slice.call(arguments, 2);
      return function() {
        return func.apply(context, args.concat(slice.call(arguments)));
      };
    };

    // Partially apply a function by creating a version that has had some of its
    // arguments pre-filled, without changing its dynamic `this` context.
    _.partial = function(func) {
      var args = slice.call(arguments, 1);
      return function() {
        return func.apply(this, args.concat(slice.call(arguments)));
      };
    };

    // Bind all of an object's methods to that object. Useful for ensuring that
    // all callbacks defined on an object belong to it.
    _.bindAll = function(obj) {
      var funcs = slice.call(arguments, 1);
      if (funcs.length === 0) funcs = _.functions(obj);
      each(funcs, f => { obj[f] = _.bind(obj[f], obj); });
      return obj;
    };

    // Memoize an expensive function by storing its results.
    _.memoize = (func, hasher) => {
      var memo = {};
      hasher || (hasher = _.identity);
      return function(...args) {
        var key = hasher.apply(this, args);
        return _.has(memo, key) ? memo[key] : (memo[key] = func.apply(this, args));
      };
    };

    // Delays a function for the given number of milliseconds, and then calls
    // it with the arguments supplied.
    _.delay = function(func, wait) {
      var args = slice.call(arguments, 2);
      return setTimeout(() => func(...args), wait);
    };

    // Defers a function, scheduling it to run after the current call stack has
    // cleared.
    _.defer = function(func) {
      return _.delay(...[func, 1].concat(slice.call(arguments, 1)));
    };

    // Returns a function, that, when invoked, will only be triggered at most once
    // during a given window of time.
    _.throttle = (func, wait) => {
      var context;
      var args;
      var timeout;
      var result;
      var previous = 0;
      var later = () => {
        previous = new Date;
        timeout = null;
        result = func.apply(context, args);
      };
      return function() {
        var now = new Date;
        var remaining = wait - (now - previous);
        context = this;
        args = arguments;
        if (remaining <= 0) {
          clearTimeout(timeout);
          timeout = null;
          previous = now;
          result = func.apply(context, args);
        } else if (!timeout) {
          timeout = setTimeout(later, remaining);
        }
        return result;
      };
    };

    // Returns a function, that, as long as it continues to be invoked, will not
    // be triggered. The function will be called after it stops being called for
    // N milliseconds. If `immediate` is passed, trigger the function on the
    // leading edge, instead of the trailing.
    _.debounce = (func, wait, immediate) => {
      var timeout;
      var result;
      return function() {
        var context = this;
        var args = arguments;
        var later = () => {
          timeout = null;
          if (!immediate) result = func.apply(context, args);
        };
        var callNow = immediate && !timeout;
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
        if (callNow) result = func.apply(context, args);
        return result;
      };
    };

    // Returns a function that will be executed at most one time, no matter how
    // often you call it. Useful for lazy initialization.
    _.once = func => {
      var ran = false;
      var memo;
      return function(...args) {
        if (ran) return memo;
        ran = true;
        memo = func.apply(this, args);
        func = null;
        return memo;
      };
    };

    // Returns the first function passed as an argument to the second,
    // allowing you to adjust arguments, run code before and after, and
    // conditionally execute the original function.
    _.wrap = (func, wrapper) => function() {
      var args = [func];
      push.apply(args, arguments);
      return wrapper.apply(this, args);
    };

    // Returns a function that is the composition of a list of functions, each
    // consuming the return value of the function that follows.
    _.compose = function(...args) {
      var funcs = args;
      return function() {
        var args = arguments;
        for (var i = funcs.length - 1; i >= 0; i--) {
          args = [funcs[i].apply(this, args)];
        }
        return args[0];
      };
    };

    // Returns a function that will only be executed after being called N times.
    _.after = (times, func) => {
      if (times <= 0) return func();
      return function(...args) {
        if (--times < 1) {
          return func.apply(this, args);
        }
      };
    };

    // Object Functions
    // ----------------

    // Retrieve the names of an object's properties.
    // Delegates to **ECMAScript 5**'s native `Object.keys`
    _.keys = nativeKeys || (obj => {
      if (obj !== Object(obj)) throw new TypeError('Invalid object');
      var keys = [];
      for (var key in obj) if (_.has(obj, key)) keys[keys.length] = key;
      return keys;
    });

    // Retrieve the values of an object's properties.
    _.values = obj => {
      var values = [];
      for (var key in obj) if (_.has(obj, key)) values.push(obj[key]);
      return values;
    };

    // Convert an object into a list of `[key, value]` pairs.
    _.pairs = obj => {
      var pairs = [];
      for (var key in obj) if (_.has(obj, key)) pairs.push([key, obj[key]]);
      return pairs;
    };

    // Invert the keys and values of an object. The values must be serializable.
    _.invert = obj => {
      var result = {};
      for (var key in obj) if (_.has(obj, key)) result[obj[key]] = key;
      return result;
    };

    // Return a sorted list of the function names available on the object.
    // Aliased as `methods`
    _.functions = _.methods = obj => {
      var names = [];
      for (var key in obj) {
        if (_.isFunction(obj[key])) names.push(key);
      }
      return names.sort();
    };

    // Extend a given object with all the properties in passed-in object(s).
    _.extend = function(obj) {
      each(slice.call(arguments, 1), source => {
        if (source) {
          for (var prop in source) {
            obj[prop] = source[prop];
          }
        }
      });
      return obj;
    };

    // Return a copy of the object only containing the whitelisted properties.
    _.pick = function(obj) {
      var copy = {};
      var keys = concat.apply(ArrayProto, slice.call(arguments, 1));
      each(keys, key => {
        if (key in obj) copy[key] = obj[key];
      });
      return copy;
    };

    // Return a copy of the object without the blacklisted properties.
    _.omit = function(obj) {
      var copy = {};
      var keys = concat.apply(ArrayProto, slice.call(arguments, 1));
      for (var key in obj) {
        if (!_.contains(keys, key)) copy[key] = obj[key];
      }
      return copy;
    };

    // Fill in a given object with default properties.
    _.defaults = function(obj) {
      each(slice.call(arguments, 1), source => {
        if (source) {
          for (var prop in source) {
            if (obj[prop] == null) obj[prop] = source[prop];
          }
        }
      });
      return obj;
    };

    // Create a (shallow-cloned) duplicate of an object.
    _.clone = obj => {
      if (!_.isObject(obj)) return obj;
      return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
    };

    // Invokes interceptor with the obj, and then returns obj.
    // The primary purpose of this method is to "tap into" a method chain, in
    // order to perform operations on intermediate results within the chain.
    _.tap = (obj, interceptor) => {
      interceptor(obj);
      return obj;
    };

    // Internal recursive comparison function for `isEqual`.
    var eq = (a, b, aStack, bStack) => {
      // Identical objects are equal. `0 === -0`, but they aren't identical.
      // See the Harmony `egal` proposal: http://wiki.ecmascript.org/doku.php?id=harmony:egal.
      if (a === b) return a !== 0 || 1 / a == 1 / b;
      // A strict comparison is necessary because `null == undefined`.
      if (a == null || b == null) return a === b;
      // Unwrap any wrapped objects.
      if (a instanceof _) a = a._wrapped;
      if (b instanceof _) b = b._wrapped;
      // Compare `[[Class]]` names.
      var className = toString.call(a);
      if (className != toString.call(b)) return false;
      switch (className) {
        // Strings, numbers, dates, and booleans are compared by value.
        case '[object String]':
          // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
          // equivalent to `new String("5")`.
          return a == String(b);
        case '[object Number]':
          // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for
          // other numeric values.
          return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);
        case '[object Date]':
        case '[object Boolean]':
          // Coerce dates and booleans to numeric primitive values. Dates are compared by their
          // millisecond representations. Note that invalid dates with millisecond representations
          // of `NaN` are not equivalent.
          return +a == +b;
        // RegExps are compared by their source patterns and flags.
        case '[object RegExp]':
          return a.source == b.source &&
                 a.global == b.global &&
                 a.multiline == b.multiline &&
                 a.ignoreCase == b.ignoreCase;
      }
      if (typeof a != 'object' || typeof b != 'object') return false;
      // Assume equality for cyclic structures. The algorithm for detecting cyclic
      // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.
      var length = aStack.length;
      while (length--) {
        // Linear search. Performance is inversely proportional to the number of
        // unique nested structures.
        if (aStack[length] == a) return bStack[length] == b;
      }
      // Add the first object to the stack of traversed objects.
      aStack.push(a);
      bStack.push(b);
      var size = 0;
      var result = true;
      // Recursively compare objects and arrays.
      if (className == '[object Array]') {
        // Compare array lengths to determine if a deep comparison is necessary.
        size = a.length;
        result = size == b.length;
        if (result) {
          // Deep compare the contents, ignoring non-numeric properties.
          while (size--) {
            if (!(result = eq(a[size], b[size], aStack, bStack))) break;
          }
        }
      } else {
        // Objects with different constructors are not equivalent, but `Object`s
        // from different frames are.
        var aCtor = a.constructor;

        var bCtor = b.constructor;
        if (aCtor !== bCtor && !(_.isFunction(aCtor) && (aCtor instanceof aCtor) &&
                                 _.isFunction(bCtor) && (bCtor instanceof bCtor))) {
          return false;
        }
        // Deep compare objects.
        for (var key in a) {
          if (_.has(a, key)) {
            // Count the expected number of properties.
            size++;
            // Deep compare each member.
            if (!(result = _.has(b, key) && eq(a[key], b[key], aStack, bStack))) break;
          }
        }
        // Ensure that both objects contain the same number of properties.
        if (result) {
          for (key in b) {
            if (_.has(b, key) && !(size--)) break;
          }
          result = !size;
        }
      }
      // Remove the first object from the stack of traversed objects.
      aStack.pop();
      bStack.pop();
      return result;
    };

    // Perform a deep comparison to check if two objects are equal.
    _.isEqual = (a, b) => eq(a, b, [], []);

    // Is a given array, string, or object empty?
    // An "empty" object has no enumerable own-properties.
    _.isEmpty = obj => {
      if (obj == null) return true;
      if (_.isArray(obj) || _.isString(obj)) return obj.length === 0;
      for (var key in obj) if (_.has(obj, key)) return false;
      return true;
    };

    // Is a given value a DOM element?
    _.isElement = obj => !!(obj && obj.nodeType === 1);

    // Is a given value an array?
    // Delegates to ECMA5's native Array.isArray
    _.isArray = nativeIsArray || (obj => toString.call(obj) == '[object Array]');

    // Is a given variable an object?
    _.isObject = obj => obj === Object(obj);

    // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp.
    each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp'], name => {
      _['is' + name] = obj => toString.call(obj) == '[object ' + name + ']';
    });

    // Define a fallback version of the method in browsers (ahem, IE), where
    // there isn't any inspectable "Arguments" type.
    if (!_.isArguments(args)) {
      _.isArguments = obj => !!(obj && _.has(obj, 'callee'));
    }

    // Optimize `isFunction` if appropriate.
    if (typeof (/./) !== 'function') {
      _.isFunction = obj => typeof obj === 'function';
    }

    // Is a given object a finite number?
    _.isFinite = obj => isFinite(obj) && !isNaN(parseFloat(obj));

    // Is the given value `NaN`? (NaN is the only number which does not equal itself).
    _.isNaN = obj => _.isNumber(obj) && obj != +obj;

    // Is a given value a boolean?
    _.isBoolean = obj => obj === true || obj === false || toString.call(obj) == '[object Boolean]';

    // Is a given value equal to null?
    _.isNull = obj => obj === null;

    // Is a given variable undefined?
    _.isUndefined = obj => obj === void 0;

    // Shortcut function for checking if an object has a given property directly
    // on itself (in other words, not on a prototype).
    _.has = (obj, key) => hasOwnProperty.call(obj, key);

    // Utility Functions
    // -----------------

    // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
    // previous owner. Returns a reference to the Underscore object.
    _.noConflict = function() {
      root._ = previousUnderscore;
      return this;
    };

    // Keep the identity function around for default iterators.
    _.identity = value => value;

    // Run a function **n** times.
    _.times = (n, iterator, context) => {
      var accum = Array(n);
      for (var i = 0; i < n; i++) accum[i] = iterator.call(context, i);
      return accum;
    };

    // Return a random integer between min and max (inclusive).
    _.random = (min, max) => {
      if (max == null) {
        max = min;
        min = 0;
      }
      return min + Math.floor(Math.random() * (max - min + 1));
    };

    // List of HTML entities for escaping.
    var entityMap = {
      escape: {
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        "'": '&#x27;',
        '/': '&#x2F;'
      }
    };
    entityMap.unescape = _.invert(entityMap.escape);

    // Regexes containing the keys and values listed immediately above.
    var entityRegexes = {
      escape:   new RegExp('[' + _.keys(entityMap.escape).join('') + ']', 'g'),
      unescape: new RegExp('(' + _.keys(entityMap.unescape).join('|') + ')', 'g')
    };

    // Functions for escaping and unescaping strings to/from HTML interpolation.
    _.each(['escape', 'unescape'], method => {
      _[method] = string => {
        if (string == null) return '';
        return ('' + string).replace(entityRegexes[method], match => entityMap[method][match]);
      };
    });

    // If the value of the named property is a function then invoke it;
    // otherwise, return it.
    _.result = (object, property) => {
      if (object == null) return null;
      var value = object[property];
      return _.isFunction(value) ? value.call(object) : value;
    };

    // Add your own custom functions to the Underscore object.
    _.mixin = obj => {
      each(_.functions(obj), name => {
        var func = _[name] = obj[name];
        _.prototype[name] = function() {
          var args = [this._wrapped];
          push.apply(args, arguments);
          return result.call(this, func.apply(_, args));
        };
      });
    };

    // Generate a unique integer id (unique within the entire client session).
    // Useful for temporary DOM ids.
    var idCounter = 0;
    _.uniqueId = prefix => {
      var id = ++idCounter + '';
      return prefix ? prefix + id : id;
    };

    // By default, Underscore uses ERB-style template delimiters, change the
    // following template settings to use alternative delimiters.
    _.templateSettings = {
      evaluate    : /<%([\s\S]+?)%>/g,
      interpolate : /<%=([\s\S]+?)%>/g,
      escape      : /<%-([\s\S]+?)%>/g
    };

    // When customizing `templateSettings`, if you don't want to define an
    // interpolation, evaluation or escaping regex, we need one that is
    // guaranteed not to match.
    var noMatch = /(.)^/;

    // Certain characters need to be escaped so that they can be put into a
    // string literal.
    var escapes = {
      "'":      "'",
      '\\':     '\\',
      '\r':     'r',
      '\n':     'n',
      '\t':     't',
      '\u2028': 'u2028',
      '\u2029': 'u2029'
    };

    var escaper = /\\|'|\r|\n|\t|\u2028|\u2029/g;

    // JavaScript micro-templating, similar to John Resig's implementation.
    // Underscore templating handles arbitrary delimiters, preserves whitespace,
    // and correctly escapes quotes within interpolated code.
    _.template = (text, data, settings) => {
      var render;
      settings = _.defaults({}, settings, _.templateSettings);

      // Combine delimiters into one regular expression via alternation.
      var matcher = new RegExp([
        (settings.escape || noMatch).source,
        (settings.interpolate || noMatch).source,
        (settings.evaluate || noMatch).source
      ].join('|') + '|$', 'g');

      // Compile the template source, escaping string literals appropriately.
      var index = 0;
      var source = "__p+='";
      text.replace(matcher, (match, escape, interpolate, evaluate, offset) => {
        source += text.slice(index, offset)
          .replace(escaper, match => '\\' + escapes[match]);

        if (escape) {
          source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
        }
        if (interpolate) {
          source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
        }
        if (evaluate) {
          source += "';\n" + evaluate + "\n__p+='";
        }
        index = offset + match.length;
        return match;
      });
      source += "';\n";

      // If a variable is not specified, place data values in local scope.
      if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

      source = "var __t,__p='',__j=Array.prototype.join," +
        "print=function(){__p+=__j.call(arguments,'');};\n" +
        source + "return __p;\n";

      try {
        render = new Function(settings.variable || 'obj', '_', source);
      } catch (e) {
        e.source = source;
        throw e;
      }

      if (data) return render(data, _);
      var template = function(data) {
        return render.call(this, data, _);
      };

      // Provide the compiled function source as a convenience for precompilation.
      template.source = 'function(' + (settings.variable || 'obj') + '){\n' + source + '}';

      return template;
    };

    // Add a "chain" function, which will delegate to the wrapper.
    _.chain = obj => _(obj).chain();

    // OOP
    // ---------------
    // If Underscore is called as a function, it returns a wrapped object that
    // can be used OO-style. This wrapper holds altered versions of all the
    // underscore functions. Wrapped objects may be chained.

    // Helper function to continue chaining intermediate results.
    var result = function(obj) {
      return this._chain ? _(obj).chain() : obj;
    };

    // Add all of the Underscore functions to the wrapper object.
    _.mixin(_);

    // Add all mutator Array functions to the wrapper.
    each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], name => {
      var method = ArrayProto[name];
      _.prototype[name] = function(...args) {
        var obj = this._wrapped;
        method.apply(obj, args);
        if ((name == 'shift' || name == 'splice') && obj.length === 0) delete obj[0];
        return result.call(this, obj);
      };
    });

    // Add all accessor Array functions to the wrapper.
    each(['concat', 'join', 'slice'], name => {
      var method = ArrayProto[name];
      _.prototype[name] = function(...args) {
        return result.call(this, method.apply(this._wrapped, args));
      };
    });

    _.extend(_.prototype, {

      // Start chaining a wrapped Underscore object.
      chain() {
        this._chain = true;
        return this;
      },

      // Extracts the result from a wrapped and chained object.
      value() {
        return this._wrapped;
      }

    });
  })).call(this);

  },{}],12:[(require, module, exports) => {


  //
  // The shims in this file are not fully implemented shims for the ES5
  // features, but do work for the particular usecases there is in
  // the other modules.
  //

  var toString = Object.prototype.toString;
  var hasOwnProperty = Object.prototype.hasOwnProperty;

  // Array.isArray is supported in IE9
  function isArray(xs) {
    return toString.call(xs) === '[object Array]';
  }
  exports.isArray = typeof Array.isArray === 'function' ? Array.isArray : isArray;

  // Array.prototype.indexOf is supported in IE9
  exports.indexOf = function indexOf(xs, x) {
    if (xs.indexOf) return xs.indexOf(x);
    for (var i = 0; i < xs.length; i++) {
      if (x === xs[i]) return i;
    }
    return -1;
  };

  // Array.prototype.filter is supported in IE9
  exports.filter = function filter(xs, fn) {
    if (xs.filter) return xs.filter(fn);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
      if (fn(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
  };

  // Array.prototype.forEach is supported in IE9
  exports.forEach = function forEach(xs, fn, self) {
    if (xs.forEach) return xs.forEach(fn, self);
    for (var i = 0; i < xs.length; i++) {
      fn.call(self, xs[i], i, xs);
    }
  };

  // Array.prototype.map is supported in IE9
  exports.map = function map(xs, fn) {
    if (xs.map) return xs.map(fn);
    var out = new Array(xs.length);
    for (var i = 0; i < xs.length; i++) {
      out[i] = fn(xs[i], i, xs);
    }
    return out;
  };

  // Array.prototype.reduce is supported in IE9
  exports.reduce = function reduce(array, callback, opt_initialValue) {
    if (array.reduce) return array.reduce(callback, opt_initialValue);
    var value;
    var isValueSet = false;

    if (2 < arguments.length) {
      value = opt_initialValue;
      isValueSet = true;
    }
    for (var i = 0, l = array.length; l > i; ++i) {
      if (array.hasOwnProperty(i)) {
        if (isValueSet) {
          value = callback(value, array[i], i, array);
        }
        else {
          value = array[i];
          isValueSet = true;
        }
      }
    }

    return value;
  };

  // String.prototype.substr - negative index don't work in IE8
  if ('ab'.substr(-1) !== 'b') {
    exports.substr = (str, start, length) => {
      // did we get a negative start, calculate how much it is from the beginning of the string
      if (start < 0) start = str.length + start;

      // call the original function
      return str.substr(start, length);
    };
  } else {
    exports.substr = (str, start, length) => str.substr(start, length);
  }

  // String.prototype.trim is supported in IE9
  exports.trim = str => {
    if (str.trim) return str.trim();
    return str.replace(/^\s+|\s+$/g, '');
  };

  // Function.prototype.bind is supported in IE9
  exports.bind = function () {
    var args = Array.prototype.slice.call(arguments);
    var fn = args.shift();
    if (fn.bind) return fn.bind(...args);
    var self = args.shift();
    return function () {
      fn.apply(self, args.concat([Array.prototype.slice.call(arguments)]));
    };
  };

  // Object.create is supported in IE9
  function create(prototype, properties) {
    var object;
    if (prototype === null) {
      object = { '__proto__' : null };
    }
    else {
      if (typeof prototype !== 'object') {
        throw new TypeError(
          'typeof prototype[' + (typeof prototype) + '] != \'object\''
        );
      }
      var Type = () => {};
      Type.prototype = prototype;
      object = new Type();
      object.__proto__ = prototype;
    }
    if (typeof properties !== 'undefined' && Object.defineProperties) {
      Object.defineProperties(object, properties);
    }
    return object;
  }
  exports.create = typeof Object.create === 'function' ? Object.create : create;

  // Object.keys and Object.getOwnPropertyNames is supported in IE9 however
  // they do show a description and number property on Error objects
  function notObject(object) {
    return ((typeof object != "object" && typeof object != "function") || object === null);
  }

  function keysShim(object) {
    if (notObject(object)) {
      throw new TypeError("Object.keys called on a non-object");
    }

    var result = [];
    for (var name in object) {
      if (hasOwnProperty.call(object, name)) {
        result.push(name);
      }
    }
    return result;
  }

  // getOwnPropertyNames is almost the same as Object.keys one key feature
  //  is that it returns hidden properties, since that can't be implemented,
  //  this feature gets reduced so it just shows the length property on arrays
  function propertyShim(object) {
    if (notObject(object)) {
      throw new TypeError("Object.getOwnPropertyNames called on a non-object");
    }

    var result = keysShim(object);
    if (exports.isArray(object) && exports.indexOf(object, 'length') === -1) {
      result.push('length');
    }
    return result;
  }

  var keys = typeof Object.keys === 'function' ? Object.keys : keysShim;
  var getOwnPropertyNames = typeof Object.getOwnPropertyNames === 'function' ?
    Object.getOwnPropertyNames : propertyShim;

  if (new Error().hasOwnProperty('description')) {
    var ERROR_PROPERTY_FILTER = (obj, array) => {
      if (toString.call(obj) === '[object Error]') {
        array = exports.filter(array, name => name !== 'description' && name !== 'number' && name !== 'message');
      }
      return array;
    };

    exports.keys = object => ERROR_PROPERTY_FILTER(object, keys(object));
    exports.getOwnPropertyNames = object => ERROR_PROPERTY_FILTER(object, getOwnPropertyNames(object));
  } else {
    exports.keys = keys;
    exports.getOwnPropertyNames = getOwnPropertyNames;
  }

  // Object.getOwnPropertyDescriptor - supported in IE8 but only on dom elements
  function valueObject(value, key) {
    return { value: value[key] };
  }

  if (typeof Object.getOwnPropertyDescriptor === 'function') {
    try {
      Object.getOwnPropertyDescriptor({'a': 1}, 'a');
      exports.getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
    } catch (e) {
      // IE8 dom element issue - use a try catch and default to valueObject
      exports.getOwnPropertyDescriptor = (value, key) => {
        try {
          return Object.getOwnPropertyDescriptor(value, key);
        } catch (e) {
          return valueObject(value, key);
        }
      };
    }
  } else {
    exports.getOwnPropertyDescriptor = valueObject;
  }

  },{}],13:[(require, module, exports) => {
  // Copyright Joyent, Inc. and other Node contributors.
  //
  // Permission is hereby granted, free of charge, to any person obtaining a
  // copy of this software and associated documentation files (the
  // "Software"), to deal in the Software without restriction, including
  // without limitation the rights to use, copy, modify, merge, publish,
  // distribute, sublicense, and/or sell copies of the Software, and to permit
  // persons to whom the Software is furnished to do so, subject to the
  // following conditions:
  //
  // The above copyright notice and this permission notice shall be included
  // in all copies or substantial portions of the Software.
  //
  // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
  // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
  // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
  // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
  // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
  // USE OR OTHER DEALINGS IN THE SOFTWARE.

  var util = require('util');

  function EventEmitter() {
    this._events = this._events || {};
    this._maxListeners = this._maxListeners || undefined;
  }
  module.exports = EventEmitter;

  // Backwards-compat with node 0.10.x
  EventEmitter.EventEmitter = EventEmitter;

  EventEmitter.prototype._events = undefined;
  EventEmitter.prototype._maxListeners = undefined;

  // By default EventEmitters will print a warning if more than 10 listeners are
  // added to it. This is a useful default which helps finding memory leaks.
  EventEmitter.defaultMaxListeners = 10;

  // Obviously not all Emitters should be limited to 10. This function allows
  // that to be increased. Set to zero for unlimited.
  EventEmitter.prototype.setMaxListeners = function(n) {
    if (!util.isNumber(n) || n < 0)
      throw TypeError('n must be a positive number');
    this._maxListeners = n;
    return this;
  };

  EventEmitter.prototype.emit = function(type) {
    var er;
    var handler;
    var len;
    var args;
    var i;
    var listeners;

    if (!this._events)
      this._events = {};

    // If there is no 'error' event listener then throw.
    if (type === 'error') {
      if (!this._events.error ||
          (util.isObject(this._events.error) && !this._events.error.length)) {
        er = arguments[1];
        if (er instanceof Error) {
          throw er; // Unhandled 'error' event
        } else {
          throw TypeError('Uncaught, unspecified "error" event.');
        }
        return false;
      }
    }

    handler = this._events[type];

    if (util.isUndefined(handler))
      return false;

    if (util.isFunction(handler)) {
      switch (arguments.length) {
        // fast cases
        case 1:
          handler.call(this);
          break;
        case 2:
          handler.call(this, arguments[1]);
          break;
        case 3:
          handler.call(this, arguments[1], arguments[2]);
          break;
        // slower
        default:
          len = arguments.length;
          args = new Array(len - 1);
          for (i = 1; i < len; i++)
            args[i - 1] = arguments[i];
          handler.apply(this, args);
      }
    } else if (util.isObject(handler)) {
      len = arguments.length;
      args = new Array(len - 1);
      for (i = 1; i < len; i++)
        args[i - 1] = arguments[i];

      listeners = handler.slice();
      len = listeners.length;
      for (i = 0; i < len; i++)
        listeners[i].apply(this, args);
    }

    return true;
  };

  EventEmitter.prototype.addListener = function(type, listener) {
    var m;

    if (!util.isFunction(listener))
      throw TypeError('listener must be a function');

    if (!this._events)
      this._events = {};

    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (this._events.newListener)
      this.emit('newListener', type,
                util.isFunction(listener.listener) ?
                listener.listener : listener);

    if (!this._events[type])
      // Optimize the case of one listener. Don't need the extra array object.
      this._events[type] = listener;
    else if (util.isObject(this._events[type]))
      // If we've already got an array, just append.
      this._events[type].push(listener);
    else
      // Adding the second element, need to change to array.
      this._events[type] = [this._events[type], listener];

    // Check for listener leak
    if (util.isObject(this._events[type]) && !this._events[type].warned) {
      var m;
      if (!util.isUndefined(this._maxListeners)) {
        m = this._maxListeners;
      } else {
        m = EventEmitter.defaultMaxListeners;
      }

      if (m && m > 0 && this._events[type].length > m) {
        this._events[type].warned = true;
        console.error('(node) warning: possible EventEmitter memory ' +
                      'leak detected. %d listeners added. ' +
                      'Use emitter.setMaxListeners() to increase limit.',
                      this._events[type].length);
        console.trace();
      }
    }

    return this;
  };

  EventEmitter.prototype.on = EventEmitter.prototype.addListener;

  EventEmitter.prototype.once = function(type, listener) {
    if (!util.isFunction(listener))
      throw TypeError('listener must be a function');

    function g(...args) {
      this.removeListener(type, g);
      listener.apply(this, args);
    }

    g.listener = listener;
    this.on(type, g);

    return this;
  };

  // emits a 'removeListener' event iff the listener was removed
  EventEmitter.prototype.removeListener = function(type, listener) {
    var list;
    var position;
    var length;
    var i;

    if (!util.isFunction(listener))
      throw TypeError('listener must be a function');

    if (!this._events || !this._events[type])
      return this;

    list = this._events[type];
    length = list.length;
    position = -1;

    if (list === listener ||
        (util.isFunction(list.listener) && list.listener === listener)) {
      delete this._events[type];
      if (this._events.removeListener)
        this.emit('removeListener', type, listener);

    } else if (util.isObject(list)) {
      for (i = length; i-- > 0;) {
        if (list[i] === listener ||
            (list[i].listener && list[i].listener === listener)) {
          position = i;
          break;
        }
      }

      if (position < 0)
        return this;

      if (list.length === 1) {
        list.length = 0;
        delete this._events[type];
      } else {
        list.splice(position, 1);
      }

      if (this._events.removeListener)
        this.emit('removeListener', type, listener);
    }

    return this;
  };

  EventEmitter.prototype.removeAllListeners = function(type) {
    var key;
    var listeners;

    if (!this._events)
      return this;

    // not listening for removeListener, no need to emit
    if (!this._events.removeListener) {
      if (arguments.length === 0)
        this._events = {};
      else if (this._events[type])
        delete this._events[type];
      return this;
    }

    // emit removeListener for all listeners on all events
    if (arguments.length === 0) {
      for (key in this._events) {
        if (key === 'removeListener') continue;
        this.removeAllListeners(key);
      }
      this.removeAllListeners('removeListener');
      this._events = {};
      return this;
    }

    listeners = this._events[type];

    if (util.isFunction(listeners)) {
      this.removeListener(type, listeners);
    } else {
      // LIFO order
      while (listeners.length)
        this.removeListener(type, listeners[listeners.length - 1]);
    }
    delete this._events[type];

    return this;
  };

  EventEmitter.prototype.listeners = function(type) {
    var ret;
    if (!this._events || !this._events[type])
      ret = [];
    else if (util.isFunction(this._events[type]))
      ret = [this._events[type]];
    else
      ret = this._events[type].slice();
    return ret;
  };

  EventEmitter.listenerCount = (emitter, type) => {
    var ret;
    if (!emitter._events || !emitter._events[type])
      ret = 0;
    else if (util.isFunction(emitter._events[type]))
      ret = 1;
    else
      ret = emitter._events[type].length;
    return ret;
  };
  },{"util":15}],14:[(require, module, exports) => {

  // not implemented
  // The reason for having an empty file and not throwing is to allow
  // untraditional implementation of this module.

  },{}],15:[(require, module, exports) => {
  // Copyright Joyent, Inc. and other Node contributors.
  //
  // Permission is hereby granted, free of charge, to any person obtaining a
  // copy of this software and associated documentation files (the
  // "Software"), to deal in the Software without restriction, including
  // without limitation the rights to use, copy, modify, merge, publish,
  // distribute, sublicense, and/or sell copies of the Software, and to permit
  // persons to whom the Software is furnished to do so, subject to the
  // following conditions:
  //
  // The above copyright notice and this permission notice shall be included
  // in all copies or substantial portions of the Software.
  //
  // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
  // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
  // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
  // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
  // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
  // USE OR OTHER DEALINGS IN THE SOFTWARE.

  var shims = require('_shims');

  var formatRegExp = /%[sdj%]/g;
  exports.format = function(f) {
    if (!isString(f)) {
      var objects = [];
      for (var i = 0; i < arguments.length; i++) {
        objects.push(inspect(arguments[i]));
      }
      return objects.join(' ');
    }

    var i = 1;
    var args = arguments;
    var len = args.length;
    var str = String(f).replace(formatRegExp, x => {
      if (x === '%%') return '%';
      if (i >= len) return x;
      switch (x) {
        case '%s': return String(args[i++]);
        case '%d': return Number(args[i++]);
        case '%j':
          try {
            return JSON.stringify(args[i++]);
          } catch (_) {
            return '[Circular]';
          }
        default:
          return x;
      }
    });
    for (var x = args[i]; i < len; x = args[++i]) {
      if (isNull(x) || !isObject(x)) {
        str += ' ' + x;
      } else {
        str += ' ' + inspect(x);
      }
    }
    return str;
  };

  /**
   * Echos the value of a value. Trys to print the value out
   * in the best way possible given the different types.
   *
   * @param {Object} obj The object to print out.
   * @param {Object} opts Optional options object that alters the output.
   */
  /* legacy: obj, showHidden, depth, colors*/
  function inspect(obj, opts) {
    // default options
    var ctx = {
      seen: [],
      stylize: stylizeNoColor
    };
    // legacy...
    if (arguments.length >= 3) ctx.depth = arguments[2];
    if (arguments.length >= 4) ctx.colors = arguments[3];
    if (isBoolean(opts)) {
      // legacy...
      ctx.showHidden = opts;
    } else if (opts) {
      // got an "options" object
      exports._extend(ctx, opts);
    }
    // set default options
    if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
    if (isUndefined(ctx.depth)) ctx.depth = 2;
    if (isUndefined(ctx.colors)) ctx.colors = false;
    if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
    if (ctx.colors) ctx.stylize = stylizeWithColor;
    return formatValue(ctx, obj, ctx.depth);
  }
  exports.inspect = inspect;


  // http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
  inspect.colors = {
    'bold' : [1, 22],
    'italic' : [3, 23],
    'underline' : [4, 24],
    'inverse' : [7, 27],
    'white' : [37, 39],
    'grey' : [90, 39],
    'black' : [30, 39],
    'blue' : [34, 39],
    'cyan' : [36, 39],
    'green' : [32, 39],
    'magenta' : [35, 39],
    'red' : [31, 39],
    'yellow' : [33, 39]
  };

  // Don't use 'blue' not visible on cmd.exe
  inspect.styles = {
    'special': 'cyan',
    'number': 'yellow',
    'boolean': 'yellow',
    'undefined': 'grey',
    'null': 'bold',
    'string': 'green',
    'date': 'magenta',
    // "name": intentionally not styling
    'regexp': 'red'
  };


  function stylizeWithColor(str, styleType) {
    var style = inspect.styles[styleType];

    if (style) {
      return '\u001b[' + inspect.colors[style][0] + 'm' + str +
             '\u001b[' + inspect.colors[style][1] + 'm';
    } else {
      return str;
    }
  }


  function stylizeNoColor(str, styleType) {
    return str;
  }


  function arrayToHash(array) {
    var hash = {};

    shims.forEach(array, (val, idx) => {
      hash[val] = true;
    });

    return hash;
  }


  function formatValue(ctx, value, recurseTimes) {
    // Provide a hook for user-specified inspect functions.
    // Check that value is an object with an inspect function on it
    if (ctx.customInspect &&
        value &&
        isFunction(value.inspect) &&
        // Filter out the util module, it's inspect function is special
        value.inspect !== exports.inspect &&
        // Also filter out any prototype objects using the circular check.
        !(value.constructor && value.constructor.prototype === value)) {
      var ret = value.inspect(recurseTimes);
      if (!isString(ret)) {
        ret = formatValue(ctx, ret, recurseTimes);
      }
      return ret;
    }

    // Primitive types cannot have properties
    var primitive = formatPrimitive(ctx, value);
    if (primitive) {
      return primitive;
    }

    // Look up the keys of the object.
    var keys = shims.keys(value);
    var visibleKeys = arrayToHash(keys);

    if (ctx.showHidden) {
      keys = shims.getOwnPropertyNames(value);
    }

    // Some type of object without properties can be shortcutted.
    if (keys.length === 0) {
      if (isFunction(value)) {
        var name = value.name ? ': ' + value.name : '';
        return ctx.stylize('[Function' + name + ']', 'special');
      }
      if (isRegExp(value)) {
        return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
      }
      if (isDate(value)) {
        return ctx.stylize(Date.prototype.toString.call(value), 'date');
      }
      if (isError(value)) {
        return formatError(value);
      }
    }

    var base = '';
    var array = false;
    var braces = ['{', '}'];

    // Make Array say that they are Array
    if (isArray(value)) {
      array = true;
      braces = ['[', ']'];
    }

    // Make functions say that they are functions
    if (isFunction(value)) {
      var n = value.name ? ': ' + value.name : '';
      base = ' [Function' + n + ']';
    }

    // Make RegExps say that they are RegExps
    if (isRegExp(value)) {
      base = ' ' + RegExp.prototype.toString.call(value);
    }

    // Make dates with properties first say the date
    if (isDate(value)) {
      base = ' ' + Date.prototype.toUTCString.call(value);
    }

    // Make error with message first say the error
    if (isError(value)) {
      base = ' ' + formatError(value);
    }

    if (keys.length === 0 && (!array || value.length == 0)) {
      return braces[0] + base + braces[1];
    }

    if (recurseTimes < 0) {
      if (isRegExp(value)) {
        return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
      } else {
        return ctx.stylize('[Object]', 'special');
      }
    }

    ctx.seen.push(value);

    var output;
    if (array) {
      output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
    } else {
      output = keys.map(key => formatProperty(ctx, value, recurseTimes, visibleKeys, key, array));
    }

    ctx.seen.pop();

    return reduceToSingleString(output, base, braces);
  }


  function formatPrimitive(ctx, value) {
    if (isUndefined(value))
      return ctx.stylize('undefined', 'undefined');
    if (isString(value)) {
      var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                               .replace(/'/g, "\\'")
                                               .replace(/\\"/g, '"') + '\'';
      return ctx.stylize(simple, 'string');
    }
    if (isNumber(value))
      return ctx.stylize('' + value, 'number');
    if (isBoolean(value))
      return ctx.stylize('' + value, 'boolean');
    // For some reason typeof null is "object", so special case here.
    if (isNull(value))
      return ctx.stylize('null', 'null');
  }


  function formatError(value) {
    return '[' + Error.prototype.toString.call(value) + ']';
  }


  function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
    var output = [];
    for (var i = 0, l = value.length; i < l; ++i) {
      if (hasOwnProperty(value, String(i))) {
        output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
            String(i), true));
      } else {
        output.push('');
      }
    }

    shims.forEach(keys, key => {
      if (!key.match(/^\d+$/)) {
        output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
            key, true));
      }
    });
    return output;
  }


  function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
    var name;
    var str;
    var desc;
    desc = shims.getOwnPropertyDescriptor(value, key) || { value: value[key] };
    if (desc.get) {
      if (desc.set) {
        str = ctx.stylize('[Getter/Setter]', 'special');
      } else {
        str = ctx.stylize('[Getter]', 'special');
      }
    } else {
      if (desc.set) {
        str = ctx.stylize('[Setter]', 'special');
      }
    }

    if (!hasOwnProperty(visibleKeys, key)) {
      name = '[' + key + ']';
    }
    if (!str) {
      if (shims.indexOf(ctx.seen, desc.value) < 0) {
        if (isNull(recurseTimes)) {
          str = formatValue(ctx, desc.value, null);
        } else {
          str = formatValue(ctx, desc.value, recurseTimes - 1);
        }
        if (str.indexOf('\n') > -1) {
          if (array) {
            str = str.split('\n').map(line => '  ' + line).join('\n').substr(2);
          } else {
            str = '\n' + str.split('\n').map(line => '   ' + line).join('\n');
          }
        }
      } else {
        str = ctx.stylize('[Circular]', 'special');
      }
    }
    if (isUndefined(name)) {
      if (array && key.match(/^\d+$/)) {
        return str;
      }
      name = JSON.stringify('' + key);
      if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
        name = name.substr(1, name.length - 2);
        name = ctx.stylize(name, 'name');
      } else {
        name = name.replace(/'/g, "\\'")
                   .replace(/\\"/g, '"')
                   .replace(/(^"|"$)/g, "'");
        name = ctx.stylize(name, 'string');
      }
    }

    return name + ': ' + str;
  }


  function reduceToSingleString(output, base, braces) {
    var numLinesEst = 0;
    var length = shims.reduce(output, (prev, cur) => {
      numLinesEst++;
      if (cur.indexOf('\n') >= 0) numLinesEst++;
      return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
    }, 0);

    if (length > 60) {
      return braces[0] +
             (base === '' ? '' : base + '\n ') +
             ' ' +
             output.join(',\n  ') +
             ' ' +
             braces[1];
    }

    return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
  }


  // NOTE: These type checking functions intentionally don't use `instanceof`
  // because it is fragile and can be easily faked with `Object.create()`.
  function isArray(ar) {
    return shims.isArray(ar);
  }
  exports.isArray = isArray;

  function isBoolean(arg) {
    return typeof arg === 'boolean';
  }
  exports.isBoolean = isBoolean;

  function isNull(arg) {
    return arg === null;
  }
  exports.isNull = isNull;

  function isNullOrUndefined(arg) {
    return arg == null;
  }
  exports.isNullOrUndefined = isNullOrUndefined;

  function isNumber(arg) {
    return typeof arg === 'number';
  }
  exports.isNumber = isNumber;

  function isString(arg) {
    return typeof arg === 'string';
  }
  exports.isString = isString;

  function isSymbol(arg) {
    return typeof arg === 'symbol';
  }
  exports.isSymbol = isSymbol;

  function isUndefined(arg) {
    return arg === void 0;
  }
  exports.isUndefined = isUndefined;

  function isRegExp(re) {
    return isObject(re) && objectToString(re) === '[object RegExp]';
  }
  exports.isRegExp = isRegExp;

  function isObject(arg) {
    return typeof arg === 'object' && arg;
  }
  exports.isObject = isObject;

  function isDate(d) {
    return isObject(d) && objectToString(d) === '[object Date]';
  }
  exports.isDate = isDate;

  function isError(e) {
    return isObject(e) && objectToString(e) === '[object Error]';
  }
  exports.isError = isError;

  function isFunction(arg) {
    return typeof arg === 'function';
  }
  exports.isFunction = isFunction;

  function isPrimitive(arg) {
    return arg === null ||
           typeof arg === 'boolean' ||
           typeof arg === 'number' ||
           typeof arg === 'string' ||
           typeof arg === 'symbol' ||  // ES6 symbol
           typeof arg === 'undefined';
  }
  exports.isPrimitive = isPrimitive;

  function isBuffer(arg) {
    return arg && typeof arg === 'object'
      && typeof arg.copy === 'function'
      && typeof arg.fill === 'function'
      && typeof arg.binarySlice === 'function'
    ;
  }
  exports.isBuffer = isBuffer;

  function objectToString(o) {
    return Object.prototype.toString.call(o);
  }


  function pad(n) {
    return n < 10 ? '0' + n.toString(10) : n.toString(10);
  }


  var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
                'Oct', 'Nov', 'Dec'];

  // 26 Feb 16:19:34
  function timestamp() {
    var d = new Date();
    var time = [pad(d.getHours()),
                pad(d.getMinutes()),
                pad(d.getSeconds())].join(':');
    return [d.getDate(), months[d.getMonth()], time].join(' ');
  }


  // log is just a thin wrapper to console.log that prepends a timestamp
  exports.log = function(...args) {
    console.log('%s - %s', timestamp(), exports.format(...args));
  };


  /**
   * Inherit the prototype methods from one constructor into another.
   *
   * The Function.prototype.inherits from lang.js rewritten as a standalone
   * function (not on Function.prototype). NOTE: If this file is to be loaded
   * during bootstrapping this function needs to be rewritten using some native
   * functions as prototype setup using normal JavaScript does not work as
   * expected during bootstrapping (see mirror.js in r114903).
   *
   * @param {function} ctor Constructor function which needs to inherit the
   *     prototype.
   * @param {function} superCtor Constructor function to inherit prototype from.
   */
  exports.inherits = (ctor, superCtor) => {
    ctor.super_ = superCtor;
    ctor.prototype = shims.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };

  exports._extend = (origin, add) => {
    // Don't do anything if add isn't an object
    if (!add || !isObject(add)) return origin;

    var keys = shims.keys(add);
    var i = keys.length;
    while (i--) {
      origin[keys[i]] = add[keys[i]];
    }
    return origin;
  };

  function hasOwnProperty(obj, prop) {
    return Object.prototype.hasOwnProperty.call(obj, prop);
  }

  },{"_shims":12}],16:[(require, module, exports) => {
  // shim for using process in browser

  var process = module.exports = {};

  process.nextTick = ((() => {
      var canSetImmediate = typeof window !== 'undefined'
      && window.setImmediate;
      var canPost = typeof window !== 'undefined'
      && window.postMessage && window.addEventListener
      ;

      if (canSetImmediate) {
          return f => window.setImmediate(f);
      }

      if (canPost) {
          var queue = [];
          window.addEventListener('message', ev => {
              if (ev.source === window && ev.data === 'process-tick') {
                  ev.stopPropagation();
                  if (queue.length > 0) {
                      var fn = queue.shift();
                      fn();
                  }
              }
          }, true);

          return function nextTick(fn) {
              queue.push(fn);
              window.postMessage('process-tick', '*');
          };
      }

      return function nextTick(fn) {
          setTimeout(fn, 0);
      };
  }))();

  process.title = 'browser';
  process.browser = true;
  process.env = {};
  process.argv = [];

  process.binding = name => {
      throw new Error('process.binding is not supported');
  }

  // TODO(shtylman)
  process.cwd = () => '/';
  process.chdir = dir => {
      throw new Error('process.chdir is not supported');
  };

  },{}]},{},[1])
  (1);
});
;